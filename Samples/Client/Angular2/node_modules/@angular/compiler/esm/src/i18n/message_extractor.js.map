{"version":3,"file":"message_extractor.js","sourceRoot":"","sources":["../../../../../../modules/@angular/compiler/src/i18n/message_extractor.ts"],"names":[],"mappings":"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","sourcesContent":["import {Parser} from '../expression_parser/parser';\nimport {StringMapWrapper} from '../facade/collection';\nimport {isPresent} from '../facade/lang';\nimport {HtmlAst, HtmlElementAst} from '../html_ast';\nimport {HtmlParser} from '../html_parser';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from '../interpolation_config';\nimport {ParseError} from '../parse_util';\nimport {Message, id} from './message';\nimport {I18N_ATTR_PREFIX, I18nError, Part, messageFromAttribute, messageFromI18nAttribute, partition} from './shared';\n\n\n/**\n * All messages extracted from a template.\n */\nexport class ExtractionResult {\n  constructor(public messages: Message[], public errors: ParseError[]) {}\n}\n\n/**\n * Removes duplicate messages.\n */\nexport function removeDuplicates(messages: Message[]): Message[] {\n  let uniq: {[key: string]: Message} = {};\n  messages.forEach(m => {\n    if (!StringMapWrapper.contains(uniq, id(m))) {\n      uniq[id(m)] = m;\n    }\n  });\n  return StringMapWrapper.values(uniq);\n}\n\n/**\n * Extracts all messages from a template.\n *\n * Algorithm:\n *\n * To understand the algorithm, you need to know how partitioning works.\n * Partitioning is required as we can use two i18n comments to group node siblings together.\n * That is why we cannot just use nodes.\n *\n * Partitioning transforms an array of HtmlAst into an array of Part.\n * A part can optionally contain a root element or a root text node. And it can also contain\n * children.\n * A part can contain i18n property, in which case it needs to be extracted.\n *\n * Example:\n *\n * The following array of nodes will be split into four parts:\n *\n * ```\n * <a>A</a>\n * <b i18n>B</b>\n * <!-- i18n -->\n * <c>C</c>\n * D\n * <!-- /i18n -->\n * E\n * ```\n *\n * Part 1 containing the a tag. It should not be translated.\n * Part 2 containing the b tag. It should be translated.\n * Part 3 containing the c tag and the D text node. It should be translated.\n * Part 4 containing the E text node. It should not be translated..\n *\n * It is also important to understand how we stringify nodes to create a message.\n *\n * We walk the tree and replace every element node with a placeholder. We also replace\n * all expressions in interpolation with placeholders. We also insert a placeholder element\n * to wrap a text node containing interpolation.\n *\n * Example:\n *\n * The following tree:\n *\n * ```\n * <a>A{{I}}</a><b>B</b>\n * ```\n *\n * will be stringified into:\n * ```\n * <ph name=\"e0\"><ph name=\"t1\">A<ph name=\"0\"/></ph></ph><ph name=\"e2\">B</ph>\n * ```\n *\n * This is what the algorithm does:\n *\n * 1. Use the provided html parser to get the html AST of the template.\n * 2. Partition the root nodes, and process each part separately.\n * 3. If a part does not have the i18n attribute, recurse to process children and attributes.\n * 4. If a part has the i18n attribute, stringify the nodes to create a Message.\n */\nexport class MessageExtractor {\n  private _messages: Message[];\n  private _errors: ParseError[];\n\n  constructor(\n      private _htmlParser: HtmlParser, private _parser: Parser, private _implicitTags: string[],\n      private _implicitAttrs: {[k: string]: string[]}) {}\n\n  extract(\n      template: string, sourceUrl: string,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ExtractionResult {\n    this._messages = [];\n    this._errors = [];\n\n    const res = this._htmlParser.parse(template, sourceUrl, true);\n\n    if (res.errors.length == 0) {\n      this._recurse(res.rootNodes, interpolationConfig);\n    }\n\n    return new ExtractionResult(this._messages, this._errors.concat(res.errors));\n  }\n\n  private _extractMessagesFromPart(part: Part, interpolationConfig: InterpolationConfig): void {\n    if (part.hasI18n) {\n      this._messages.push(part.createMessage(this._parser, interpolationConfig));\n      this._recurseToExtractMessagesFromAttributes(part.children, interpolationConfig);\n    } else {\n      this._recurse(part.children, interpolationConfig);\n    }\n\n    if (isPresent(part.rootElement)) {\n      this._extractMessagesFromAttributes(part.rootElement, interpolationConfig);\n    }\n  }\n\n  private _recurse(nodes: HtmlAst[], interpolationConfig: InterpolationConfig): void {\n    if (isPresent(nodes)) {\n      let parts = partition(nodes, this._errors, this._implicitTags);\n      parts.forEach(part => this._extractMessagesFromPart(part, interpolationConfig));\n    }\n  }\n\n  private _recurseToExtractMessagesFromAttributes(\n      nodes: HtmlAst[], interpolationConfig: InterpolationConfig): void {\n    nodes.forEach(n => {\n      if (n instanceof HtmlElementAst) {\n        this._extractMessagesFromAttributes(n, interpolationConfig);\n        this._recurseToExtractMessagesFromAttributes(n.children, interpolationConfig);\n      }\n    });\n  }\n\n  private _extractMessagesFromAttributes(\n      p: HtmlElementAst, interpolationConfig: InterpolationConfig): void {\n    let transAttrs: string[] =\n        isPresent(this._implicitAttrs[p.name]) ? this._implicitAttrs[p.name] : [];\n    let explicitAttrs: string[] = [];\n\n    // `i18n-` prefixed attributes should be translated\n    p.attrs.filter(attr => attr.name.startsWith(I18N_ATTR_PREFIX)).forEach(attr => {\n      try {\n        explicitAttrs.push(attr.name.substring(I18N_ATTR_PREFIX.length));\n        this._messages.push(messageFromI18nAttribute(this._parser, interpolationConfig, p, attr));\n      } catch (e) {\n        if (e instanceof I18nError) {\n          this._errors.push(e);\n        } else {\n          throw e;\n        }\n      }\n    });\n\n    // implicit attributes should also be translated\n    p.attrs.filter(attr => !attr.name.startsWith(I18N_ATTR_PREFIX))\n        .filter(attr => explicitAttrs.indexOf(attr.name) == -1)\n        .filter(attr => transAttrs.indexOf(attr.name) > -1)\n        .forEach(\n            attr =>\n                this._messages.push(messageFromAttribute(this._parser, interpolationConfig, attr)));\n  }\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}