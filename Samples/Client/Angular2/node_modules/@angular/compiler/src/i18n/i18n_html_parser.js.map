{"version":3,"file":"i18n_html_parser.js","sourceRoot":"","sources":["../../../../../modules/@angular/compiler/src/i18n/i18n_html_parser.ts"],"names":[],"mappings":"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","sourcesContent":["import {Parser} from '../expression_parser/parser';\nimport {ListWrapper, StringMapWrapper} from '../facade/collection';\nimport {BaseException} from '../facade/exceptions';\nimport {NumberWrapper, RegExpWrapper, isPresent} from '../facade/lang';\nimport {HtmlAst, HtmlAstVisitor, HtmlAttrAst, HtmlCommentAst, HtmlElementAst, HtmlExpansionAst, HtmlExpansionCaseAst, HtmlTextAst, htmlVisitAll} from '../html_ast';\nimport {HtmlParseTreeResult, HtmlParser} from '../html_parser';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from '../interpolation_config';\nimport {ParseError, ParseSourceSpan} from '../parse_util';\n\nimport {expandNodes} from './expander';\nimport {Message, id} from './message';\nimport {I18N_ATTR, I18N_ATTR_PREFIX, I18nError, Part, dedupePhName, getPhNameFromBinding, messageFromAttribute, messageFromI18nAttribute, partition} from './shared';\n\nconst _PLACEHOLDER_ELEMENT = 'ph';\nconst _NAME_ATTR = 'name';\nlet _PLACEHOLDER_EXPANDED_REGEXP = /<ph(\\s)+name=(\"(\\w)+\")><\\/ph>/gi;\n\n/**\n * Creates an i18n-ed version of the parsed template.\n *\n * Algorithm:\n *\n * See `message_extractor.ts` for details on the partitioning algorithm.\n *\n * This is how the merging works:\n *\n * 1. Use the stringify function to get the message id. Look up the message in the map.\n * 2. Get the translated message. At this point we have two trees: the original tree\n * and the translated tree, where all the elements are replaced with placeholders.\n * 3. Use the original tree to create a mapping Index:number -> HtmlAst.\n * 4. Walk the translated tree.\n * 5. If we encounter a placeholder element, get its name property.\n * 6. Get the type and the index of the node using the name property.\n * 7. If the type is 'e', which means element, then:\n *     - translate the attributes of the original element\n *     - recurse to merge the children\n *     - create a new element using the original element name, original position,\n *     and translated children and attributes\n * 8. If the type if 't', which means text, then:\n *     - get the list of expressions from the original node.\n *     - get the string version of the interpolation subtree\n *     - find all the placeholders in the translated message, and replace them with the\n *     corresponding original expressions\n */\nexport class I18nHtmlParser implements HtmlParser {\n  errors: ParseError[];\n  private _interpolationConfig: InterpolationConfig;\n\n  constructor(\n      private _htmlParser: HtmlParser, private _parser: Parser, private _messagesContent: string,\n      private _messages: {[key: string]: HtmlAst[]}, private _implicitTags: string[],\n      private _implicitAttrs: {[k: string]: string[]}) {}\n\n  parse(\n      sourceContent: string, sourceUrl: string, parseExpansionForms: boolean = false,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG):\n      HtmlParseTreeResult {\n    this.errors = [];\n    this._interpolationConfig = interpolationConfig;\n\n    let res = this._htmlParser.parse(sourceContent, sourceUrl, true);\n\n    if (res.errors.length > 0) {\n      return res;\n    } else {\n      let expanded = expandNodes(res.rootNodes);\n      let nodes = this._recurse(expanded.nodes);\n      this.errors.push(...expanded.errors);\n\n      return this.errors.length > 0 ? new HtmlParseTreeResult([], this.errors) :\n                                      new HtmlParseTreeResult(nodes, []);\n    }\n  }\n\n  private _processI18nPart(part: Part): HtmlAst[] {\n    try {\n      return part.hasI18n ? this._mergeI18Part(part) : this._recurseIntoI18nPart(part);\n    } catch (e) {\n      if (e instanceof I18nError) {\n        this.errors.push(e);\n        return [];\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  private _mergeI18Part(part: Part): HtmlAst[] {\n    let message = part.createMessage(this._parser, this._interpolationConfig);\n    let messageId = id(message);\n    if (!StringMapWrapper.contains(this._messages, messageId)) {\n      throw new I18nError(\n          part.sourceSpan,\n          `Cannot find message for id '${messageId}', content '${message.content}'.`);\n    }\n\n    let parsedMessage = this._messages[messageId];\n    return this._mergeTrees(part, parsedMessage, part.children);\n  }\n\n  private _recurseIntoI18nPart(p: Part): HtmlAst[] {\n    // we found an element without an i18n attribute\n    // we need to recurse in cause its children may have i18n set\n    // we also need to translate its attributes\n    if (isPresent(p.rootElement)) {\n      let root = p.rootElement;\n      let children = this._recurse(p.children);\n      let attrs = this._i18nAttributes(root);\n      return [new HtmlElementAst(\n          root.name, attrs, children, root.sourceSpan, root.startSourceSpan, root.endSourceSpan)];\n\n      // a text node without i18n or interpolation, nothing to do\n    } else if (isPresent(p.rootTextNode)) {\n      return [p.rootTextNode];\n\n    } else {\n      return this._recurse(p.children);\n    }\n  }\n\n  private _recurse(nodes: HtmlAst[]): HtmlAst[] {\n    let parts = partition(nodes, this.errors, this._implicitTags);\n    return ListWrapper.flatten(parts.map(p => this._processI18nPart(p)));\n  }\n\n  private _mergeTrees(p: Part, translated: HtmlAst[], original: HtmlAst[]): HtmlAst[] {\n    let l = new _CreateNodeMapping();\n    htmlVisitAll(l, original);\n\n    // merge the translated tree with the original tree.\n    // we do it by preserving the source code position of the original tree\n    let merged = this._mergeTreesHelper(translated, l.mapping);\n\n    // if the root element is present, we need to create a new root element with its attributes\n    // translated\n    if (isPresent(p.rootElement)) {\n      let root = p.rootElement;\n      let attrs = this._i18nAttributes(root);\n      return [new HtmlElementAst(\n          root.name, attrs, merged, root.sourceSpan, root.startSourceSpan, root.endSourceSpan)];\n\n      // this should never happen with a part. Parts that have root text node should not be merged.\n    } else if (isPresent(p.rootTextNode)) {\n      throw new BaseException('should not be reached');\n\n    } else {\n      return merged;\n    }\n  }\n\n  private _mergeTreesHelper(translated: HtmlAst[], mapping: HtmlAst[]): HtmlAst[] {\n    return translated.map(t => {\n      if (t instanceof HtmlElementAst) {\n        return this._mergeElementOrInterpolation(t, translated, mapping);\n\n      } else if (t instanceof HtmlTextAst) {\n        return t;\n\n      } else {\n        throw new BaseException('should not be reached');\n      }\n    });\n  }\n\n  private _mergeElementOrInterpolation(\n      t: HtmlElementAst, translated: HtmlAst[], mapping: HtmlAst[]): HtmlAst {\n    let name = this._getName(t);\n    let type = name[0];\n    let index = NumberWrapper.parseInt(name.substring(1), 10);\n    let originalNode = mapping[index];\n\n    if (type == 't') {\n      return this._mergeTextInterpolation(t, <HtmlTextAst>originalNode);\n    } else if (type == 'e') {\n      return this._mergeElement(t, <HtmlElementAst>originalNode, mapping);\n    } else {\n      throw new BaseException('should not be reached');\n    }\n  }\n\n  private _getName(t: HtmlElementAst): string {\n    if (t.name != _PLACEHOLDER_ELEMENT) {\n      throw new I18nError(\n          t.sourceSpan,\n          `Unexpected tag \"${t.name}\". Only \"${_PLACEHOLDER_ELEMENT}\" tags are allowed.`);\n    }\n    let names = t.attrs.filter(a => a.name == _NAME_ATTR);\n    if (names.length == 0) {\n      throw new I18nError(t.sourceSpan, `Missing \"${_NAME_ATTR}\" attribute.`);\n    }\n    return names[0].value;\n  }\n\n  private _mergeTextInterpolation(t: HtmlElementAst, originalNode: HtmlTextAst): HtmlTextAst {\n    let split = this._parser.splitInterpolation(\n        originalNode.value, originalNode.sourceSpan.toString(), this._interpolationConfig);\n    let exps = isPresent(split) ? split.expressions : [];\n\n    let messageSubstring =\n        this._messagesContent.substring(t.startSourceSpan.end.offset, t.endSourceSpan.start.offset);\n    let translated =\n        this._replacePlaceholdersWithExpressions(messageSubstring, exps, originalNode.sourceSpan);\n\n    return new HtmlTextAst(translated, originalNode.sourceSpan);\n  }\n\n  private _mergeElement(t: HtmlElementAst, originalNode: HtmlElementAst, mapping: HtmlAst[]):\n      HtmlElementAst {\n    let children = this._mergeTreesHelper(t.children, mapping);\n    return new HtmlElementAst(\n        originalNode.name, this._i18nAttributes(originalNode), children, originalNode.sourceSpan,\n        originalNode.startSourceSpan, originalNode.endSourceSpan);\n  }\n\n  private _i18nAttributes(el: HtmlElementAst): HtmlAttrAst[] {\n    let res: HtmlAttrAst[] = [];\n    let implicitAttrs: string[] =\n        isPresent(this._implicitAttrs[el.name]) ? this._implicitAttrs[el.name] : [];\n\n    el.attrs.forEach(attr => {\n      if (attr.name.startsWith(I18N_ATTR_PREFIX) || attr.name == I18N_ATTR) return;\n\n      let message: Message;\n\n      let i18ns = el.attrs.filter(a => a.name == `${I18N_ATTR_PREFIX}${attr.name}`);\n\n      if (i18ns.length == 0) {\n        if (implicitAttrs.indexOf(attr.name) == -1) {\n          res.push(attr);\n          return;\n        }\n        message = messageFromAttribute(this._parser, this._interpolationConfig, attr);\n      } else {\n        message = messageFromI18nAttribute(this._parser, this._interpolationConfig, el, i18ns[0]);\n      }\n\n      let messageId = id(message);\n\n      if (StringMapWrapper.contains(this._messages, messageId)) {\n        let updatedMessage = this._replaceInterpolationInAttr(attr, this._messages[messageId]);\n        res.push(new HtmlAttrAst(attr.name, updatedMessage, attr.sourceSpan));\n\n      } else {\n        throw new I18nError(\n            attr.sourceSpan,\n            `Cannot find message for id '${messageId}', content '${message.content}'.`);\n      }\n    });\n    return res;\n  }\n\n  private _replaceInterpolationInAttr(attr: HtmlAttrAst, msg: HtmlAst[]): string {\n    let split = this._parser.splitInterpolation(\n        attr.value, attr.sourceSpan.toString(), this._interpolationConfig);\n    let exps = isPresent(split) ? split.expressions : [];\n\n    let first = msg[0];\n    let last = msg[msg.length - 1];\n\n    let start = first.sourceSpan.start.offset;\n    let end =\n        last instanceof HtmlElementAst ? last.endSourceSpan.end.offset : last.sourceSpan.end.offset;\n    let messageSubstring = this._messagesContent.substring(start, end);\n\n    return this._replacePlaceholdersWithExpressions(messageSubstring, exps, attr.sourceSpan);\n  };\n\n  private _replacePlaceholdersWithExpressions(\n      message: string, exps: string[], sourceSpan: ParseSourceSpan): string {\n    let expMap = this._buildExprMap(exps);\n    return RegExpWrapper.replaceAll(_PLACEHOLDER_EXPANDED_REGEXP, message, (match: string[]) => {\n      let nameWithQuotes = match[2];\n      let name = nameWithQuotes.substring(1, nameWithQuotes.length - 1);\n      return this._convertIntoExpression(name, expMap, sourceSpan);\n    });\n  }\n\n  private _buildExprMap(exps: string[]): Map<string, string> {\n    let expMap = new Map<string, string>();\n    let usedNames = new Map<string, number>();\n\n    for (var i = 0; i < exps.length; i++) {\n      let phName = getPhNameFromBinding(exps[i], i);\n      expMap.set(dedupePhName(usedNames, phName), exps[i]);\n    }\n    return expMap;\n  }\n\n  private _convertIntoExpression(\n      name: string, expMap: Map<string, string>, sourceSpan: ParseSourceSpan) {\n    if (expMap.has(name)) {\n      return `${this._interpolationConfig.start}${expMap.get(name)}${this._interpolationConfig.end}`;\n    } else {\n      throw new I18nError(sourceSpan, `Invalid interpolation name '${name}'`);\n    }\n  }\n}\n\nclass _CreateNodeMapping implements HtmlAstVisitor {\n  mapping: HtmlAst[] = [];\n\n  visitElement(ast: HtmlElementAst, context: any): any {\n    this.mapping.push(ast);\n    htmlVisitAll(this, ast.children);\n    return null;\n  }\n\n  visitAttr(ast: HtmlAttrAst, context: any): any { return null; }\n\n  visitText(ast: HtmlTextAst, context: any): any {\n    this.mapping.push(ast);\n    return null;\n  }\n\n  visitExpansion(ast: HtmlExpansionAst, context: any): any { return null; }\n\n  visitExpansionCase(ast: HtmlExpansionCaseAst, context: any): any { return null; }\n\n  visitComment(ast: HtmlCommentAst, context: any): any { return ''; }\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}