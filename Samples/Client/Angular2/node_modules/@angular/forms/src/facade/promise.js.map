{"version":3,"file":"promise.js","sourceRoot":"","sources":["../../../../../modules/@angular/forms/src/facade/promise.ts"],"names":[],"mappings":";AACA;IAKE;QALF,iBAWC;QALG,IAAI,CAAC,OAAO,GAAG,IAAI,OAAO,CAAC,UAAC,GAAG,EAAE,GAAG;YAClC,KAAI,CAAC,OAAO,GAAG,GAAG,CAAC;YACnB,KAAI,CAAC,MAAM,GAAG,GAAG,CAAC;QACpB,CAAC,CAAC,CAAC;IACL,CAAC;IACH,uBAAC;AAAD,CAAC,AAXD,IAWC;AAXY,wBAAgB,mBAW5B,CAAA;AAED;IAAA;IAsCA,CAAC;IArCQ,sBAAO,GAAd,UAAkB,GAAM,IAAgB,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IAE/D,qBAAM,GAAb,UAAc,GAAQ,EAAE,CAAM,IAAkB,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IAE7E,yEAAyE;IACzE,uBAAuB;IAChB,yBAAU,GAAjB,UAAqB,OAAmB,EAAE,OAA2C;QAEnF,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;IAChC,CAAC;IAEM,kBAAG,GAAV,UAAc,QAA0B;QACtC,EAAE,CAAC,CAAC,QAAQ,CAAC,MAAM,IAAI,CAAC,CAAC;YAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;QACrD,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;IAC/B,CAAC;IAEM,mBAAI,GAAX,UACI,OAAmB,EAAE,OAAyC,EAC9D,SAA2D;QAC7D,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;IAC1C,CAAC;IAEM,mBAAI,GAAX,UAAe,WAAoB;QACjC,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,GAAG,EAAE,GAAG;YAC1B,IAAI,CAAC;gBACH,GAAG,CAAC,WAAW,EAAE,CAAC,CAAC;YACrB,CAAE;YAAA,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACX,GAAG,CAAC,CAAC,CAAC,CAAC;YACT,CAAC;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAEM,gCAAiB,GAAxB,UAAyB,WAAsB;QAC7C,cAAc,CAAC,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,WAAW,EAAE,UAAC,CAAC,IAAM,CAAC,CAAC,CAAC;IAC5E,CAAC;IAEM,wBAAS,GAAhB,cAA6C,MAAM,CAAC,IAAI,gBAAgB,EAAK,CAAC,CAAC,CAAC;IAClF,qBAAC;AAAD,CAAC,AAtCD,IAsCC;AAtCY,sBAAc,iBAsC1B,CAAA","sourcesContent":["\nexport class PromiseCompleter<R> {\n  promise: Promise<R>;\n  resolve: (value?: R|PromiseLike<R>) => void;\n  reject: (error?: any, stackTrace?: string) => void;\n\n  constructor() {\n    this.promise = new Promise((res, rej) => {\n      this.resolve = res;\n      this.reject = rej;\n    });\n  }\n}\n\nexport class PromiseWrapper {\n  static resolve<T>(obj: T): Promise<T> { return Promise.resolve(obj); }\n\n  static reject(obj: any, _: any): Promise<any> { return Promise.reject(obj); }\n\n  // Note: We can't rename this method into `catch`, as this is not a valid\n  // method name in Dart.\n  static catchError<T>(promise: Promise<T>, onError: (error: any) => T | PromiseLike<T>):\n      Promise<T> {\n    return promise.catch(onError);\n  }\n\n  static all<T>(promises: (T|Promise<T>)[]): Promise<T[]> {\n    if (promises.length == 0) return Promise.resolve([]);\n    return Promise.all(promises);\n  }\n\n  static then<T, U>(\n      promise: Promise<T>, success: (value: T) => U | PromiseLike<U>,\n      rejection?: (error: any, stack?: any) => U | PromiseLike<U>): Promise<U> {\n    return promise.then(success, rejection);\n  }\n\n  static wrap<T>(computation: () => T): Promise<T> {\n    return new Promise((res, rej) => {\n      try {\n        res(computation());\n      } catch (e) {\n        rej(e);\n      }\n    });\n  }\n\n  static scheduleMicrotask(computation: () => any): void {\n    PromiseWrapper.then(PromiseWrapper.resolve(null), computation, (_) => {});\n  }\n\n  static completer<T>(): PromiseCompleter<T> { return new PromiseCompleter<T>(); }\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}