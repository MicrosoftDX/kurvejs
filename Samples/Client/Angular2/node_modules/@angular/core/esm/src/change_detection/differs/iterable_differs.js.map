{"version":3,"file":"iterable_differs.js","sourceRoot":"","sources":["../../../../../../../modules/@angular/core/src/change_detection/differs/iterable_differs.ts"],"names":[],"mappings":"OAAO,EAAC,gBAAgB,EAAE,QAAQ,EAAE,gBAAgB,EAAC,MAAM,UAAU;OAC9D,EAAC,WAAW,EAAC,MAAM,yBAAyB;OAC5C,EAAC,aAAa,EAAC,MAAM,yBAAyB;OAC9C,EAAC,uBAAuB,EAAE,OAAO,EAAE,SAAS,EAAC,MAAM,mBAAmB;AA8B7E;;;;GAIG;AACH;IACE,kBAAkB;IAClB,YAAmB,SAAkC;QAAlC,cAAS,GAAT,SAAS,CAAyB;IAAG,CAAC;IAEzD,OAAO,MAAM,CAAC,SAAkC,EAAE,MAAwB;QACxE,EAAE,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;YACtB,IAAI,MAAM,GAAG,WAAW,CAAC,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;YACjD,SAAS,GAAG,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;YACrC,MAAM,CAAC,IAAI,eAAe,CAAC,SAAS,CAAC,CAAC;QACxC,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,MAAM,CAAC,IAAI,eAAe,CAAC,SAAS,CAAC,CAAC;QACxC,CAAC;IACH,CAAC;IAED;;;;;;;;;;;;;;;;;;OAkBG;IACH,OAAO,MAAM,CAAC,SAAkC;QAC9C,MAAM,CAAC,IAAI,QAAQ,CAAC,eAAe,EAAE;YACnC,UAAU,EAAE,CAAC,MAAuB;gBAClC,EAAE,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;oBACpB,0FAA0F;oBAC1F,KAAK;oBACL,6EAA6E;oBAC7E,MAAM,IAAI,aAAa,CAAC,yDAAyD,CAAC,CAAC;gBACrF,CAAC;gBACD,MAAM,CAAC,eAAe,CAAC,MAAM,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;YACnD,CAAC;YACD,6FAA6F;YAC7F,IAAI,EAAE,CAAC,CAAC,eAAe,EAAE,IAAI,gBAAgB,EAAE,EAAE,IAAI,gBAAgB,EAAE,CAAC,CAAC;SAC1E,CAAC,CAAC;IACL,CAAC;IAED,IAAI,CAAC,QAAa;QAChB,IAAI,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC;QAC7D,EAAE,CAAC,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;YACvB,MAAM,CAAC,OAAO,CAAC;QACjB,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,MAAM,IAAI,aAAa,CACnB,2CAA2C,QAAQ,cAAc,uBAAuB,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;QAC7G,CAAC;IACH,CAAC;AACH,CAAC;AAAA","sourcesContent":["import {OptionalMetadata, Provider, SkipSelfMetadata} from '../../di';\nimport {ListWrapper} from '../../facade/collection';\nimport {BaseException} from '../../facade/exceptions';\nimport {getTypeNameForDebugging, isBlank, isPresent} from '../../facade/lang';\nimport {ChangeDetectorRef} from '../change_detector_ref';\n\n\n/**\n * A strategy for tracking changes over time to an iterable. Used for {@link NgFor} to\n * respond to changes in an iterable by effecting equivalent changes in the DOM.\n *\n * @stable\n */\nexport interface IterableDiffer {\n  diff(object: any): any;\n  onDestroy(): any /** TODO #9100 */;\n}\n\n/**\n  * An optional function passed into {@link NgFor} that defines how to track\n  * items in an iterable (e.g. by index or id)\n */\nexport interface TrackByFn { (index: number, item: any): any; }\n\n\n/**\n * Provides a factory for {@link IterableDiffer}.\n */\nexport interface IterableDifferFactory {\n  supports(objects: any): boolean;\n  create(cdRef: ChangeDetectorRef, trackByFn?: TrackByFn): IterableDiffer;\n}\n\n/**\n * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.\n * @ts2dart_const\n * @stable\n */\nexport class IterableDiffers {\n  /*@ts2dart_const*/\n  constructor(public factories: IterableDifferFactory[]) {}\n\n  static create(factories: IterableDifferFactory[], parent?: IterableDiffers): IterableDiffers {\n    if (isPresent(parent)) {\n      var copied = ListWrapper.clone(parent.factories);\n      factories = factories.concat(copied);\n      return new IterableDiffers(factories);\n    } else {\n      return new IterableDiffers(factories);\n    }\n  }\n\n  /**\n   * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the\n   * inherited {@link IterableDiffers} instance with the provided factories and return a new\n   * {@link IterableDiffers} instance.\n   *\n   * The following example shows how to extend an existing list of factories,\n         * which will only be applied to the injector for this component and its children.\n         * This step is all that's required to make a new {@link IterableDiffer} available.\n   *\n   * ### Example\n   *\n   * ```\n   * @Component({\n   *   viewProviders: [\n   *     IterableDiffers.extend([new ImmutableListDiffer()])\n   *   ]\n   * })\n   * ```\n   */\n  static extend(factories: IterableDifferFactory[]): Provider {\n    return new Provider(IterableDiffers, {\n      useFactory: (parent: IterableDiffers) => {\n        if (isBlank(parent)) {\n          // Typically would occur when calling IterableDiffers.extend inside of dependencies passed\n          // to\n          // bootstrap(), which would override default pipes instead of extending them.\n          throw new BaseException('Cannot extend IterableDiffers without a parent injector');\n        }\n        return IterableDiffers.create(factories, parent);\n      },\n      // Dependency technically isn't optional, but we can provide a better error message this way.\n      deps: [[IterableDiffers, new SkipSelfMetadata(), new OptionalMetadata()]]\n    });\n  }\n\n  find(iterable: any): IterableDifferFactory {\n    var factory = this.factories.find(f => f.supports(iterable));\n    if (isPresent(factory)) {\n      return factory;\n    } else {\n      throw new BaseException(\n          `Cannot find a differ supporting object '${iterable}' of type '${getTypeNameForDebugging(iterable)}'`);\n    }\n  }\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}