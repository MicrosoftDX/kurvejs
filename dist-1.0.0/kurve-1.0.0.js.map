{"version":3,"sources":["identity.ts","promises.ts","graph.ts"],"names":[],"mappings":";;;;;AAAA,6HAA6H;AAmjB7H,2DAA2D;AAC3D,EAAE;AACF,kDAAkD;AAClD,EAAE;AACF,qCAAqC;AACrC,sBAAsB;AACtB,EAAE;AACF,eAAe;AACf,wEAAwE;AACxE,kEAAkE;AAClE,wEAAwE;AACxE,sEAAsE;AACtE,qEAAqE;AACrE,wEAAwE;AACxE,4BAA4B;AAK5B,iEAAiE;AACjE,kEAAkE;AAKlE,oEAAoE;AACpE,qEAAqE;AACrE,wDAAwD;AACxD,yEAAyE;AACzE,yEAAyE;AACzE,wEAAwE;AACxE,kEAAkE;AAClE,EAAE;AACF,2DAA2D;ACplB3D,sFAAsF;AACtF,6HAA6H;AAuO7H,2DAA2D;AAC3D,EAAE;AACF,kDAAkD;AAClD,EAAE;AACF,qCAAqC;AACrC,sBAAsB;AACtB,EAAE;AACF,eAAe;AACf,wEAAwE;AACxE,kEAAkE;AAClE,wEAAwE;AACxE,sEAAsE;AACtE,qEAAqE;AACrE,wEAAwE;AACxE,4BAA4B;AAK5B,iEAAiE;AACjE,kEAAkE;AAKlE,oEAAoE;AACpE,qEAAqE;AACrE,wDAAwD;AACxD,yEAAyE;AACzE,yEAAyE;AACzE,wEAAwE;AACxE,kEAAkE;AAClE,EAAE;AACF,2DAA2D;ACzQ3D,6HAA6H;AA04B7H,2DAA2D;AAC3D,EAAE;AACF,kDAAkD;AAClD,EAAE;AACF,qCAAqC;AACrC,sBAAsB;AACtB,EAAE;AACF,eAAe;AACf,wEAAwE;AACxE,kEAAkE;AAClE,wEAAwE;AACxE,sEAAsE;AACtE,qEAAqE;AACrE,wEAAwE;AACxE,4BAA4B;AAK5B,iEAAiE;AACjE,kEAAkE;AAKlE,oEAAoE;AACpE,qEAAqE;AACrE,wDAAwD;AACxD,yEAAyE;AACzE,yEAAyE;AACzE,wEAAwE;AACxE,kEAAkE;AAClE,EAAE;AACF,2DAA2D","file":"kurve-1.0.0.js","sourcesContent":["// Copyright (c) Microsoft. All rights reserved. Licensed under the MIT license. See full license at the bottom of this file.\r\n\r\nimport { Deferred, Promise, PromiseCallback } from \"./promises\";\r\n\r\n    export enum OAuthVersion {\r\n        v1=1,\r\n        v2=2\r\n    }\r\n\r\n    export class Error {\r\n        public status: number;\r\n        public statusText: string;\r\n        public text: string;\r\n        public other: any;\r\n    }\r\n\r\n    class CachedToken {\r\n        constructor(\r\n            public id: string,\r\n            public scopes: string[],\r\n            public resource: string,\r\n            public token: string,\r\n            public expiry: Date) {};\r\n\r\n        public get isExpired() {\r\n            return this.expiry <= new Date(new Date().getTime() + 60000);\r\n        }\r\n\r\n        public hasScopes(requiredScopes: string[]) {\r\n            if (!this.scopes) {\r\n                return false;\r\n            }\r\n\r\n            return requiredScopes.every(requiredScope => {\r\n                return this.scopes.some(actualScope => requiredScope === actualScope);\r\n            });\r\n        }\r\n    }\r\n\r\n    interface CachedTokenDictionary {\r\n        [index: string]: CachedToken;\r\n    }\r\n\r\n    export interface TokenStorage {\r\n        add(key: string, token: any);\r\n        remove(key: string);\r\n        getAll(): any[];\r\n        clear();\r\n    }\r\n\r\n    class TokenCache {\r\n        private cachedTokens: CachedTokenDictionary;\r\n\r\n        constructor(private tokenStorage: TokenStorage) {\r\n            this.cachedTokens = {};\r\n            if (tokenStorage) {\r\n                tokenStorage.getAll().forEach(({ id, scopes, resource, token, expiry }) => {\r\n                    var cachedToken = new CachedToken(id, scopes, resource, token, new Date(expiry));\r\n                    if (cachedToken.isExpired) {\r\n                        this.tokenStorage.remove(cachedToken.id);\r\n                    } else {\r\n                        this.cachedTokens[cachedToken.id] = cachedToken;\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        public add(token: CachedToken) {\r\n            this.cachedTokens[token.id] = token;\r\n            this.tokenStorage && this.tokenStorage.add(token.id, token);\r\n        }\r\n\r\n        public getForResource(resource: string): CachedToken {\r\n            var cachedToken = this.cachedTokens[resource];\r\n            if (cachedToken && cachedToken.isExpired) {\r\n                this.remove(resource);\r\n                return null;\r\n            }\r\n            return cachedToken;\r\n        }\r\n\r\n        public getForScopes(scopes: string[]): CachedToken {\r\n            for (var key in this.cachedTokens) {\r\n                var cachedToken = this.cachedTokens[key];\r\n\r\n                if (cachedToken.hasScopes(scopes)) {\r\n                    if (cachedToken.isExpired) {\r\n                        this.remove(key);\r\n                    } else {\r\n                        return cachedToken;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        public clear() {\r\n            this.cachedTokens = {};\r\n            this.tokenStorage && this.tokenStorage.clear();\r\n        }\r\n\r\n        private remove(key) {\r\n            this.tokenStorage && this.tokenStorage.remove(key);\r\n            delete this.cachedTokens[key];\r\n        }\r\n    }\r\n\r\n    export class IdToken {\r\n        public Token: string;\r\n        public IssuerIdentifier: string;\r\n        public SubjectIdentifier: string;\r\n        public Audience: string;\r\n        public Expiry: Date;\r\n        public UPN: string;\r\n        public TenantId: string;\r\n        public FamilyName: string;\r\n        public GivenName: string;\r\n        public Name: string;\r\n        public PreferredUsername: string;\r\n        public FullToken: any;\r\n\r\n    }\r\n\r\n    export interface IdentitySettings {\r\n        clientId: string;\r\n        tokenProcessingUri: string;\r\n        version: OAuthVersion;\r\n        tokenStorage?: TokenStorage;\r\n    }\r\n\r\n    export class Identity {\r\n//      public authContext: any = null;\r\n//      public config: any = null;\r\n//      public isCallback: boolean = false;\r\n        public clientId: string;\r\n//      private req: XMLHttpRequest;\r\n        private state: string;\r\n        private version: OAuthVersion;\r\n        private nonce: string;\r\n        private idToken: IdToken;\r\n        private loginCallback: (error: Error) => void;\r\n//      private accessTokenCallback: (token: string, error: Error) => void;\r\n        private getTokenCallback: (token: string, error: Error) => void;\r\n        private tokenProcessorUrl: string;\r\n        private tokenCache: TokenCache;\r\n//      private logonUser: any;\r\n        private refreshTimer: any;\r\n        private policy: string = \"\";\r\n//      private tenant: string = \"\";\r\n\r\n        constructor(identitySettings: IdentitySettings) {\r\n            this.clientId = identitySettings.clientId;\r\n            this.tokenProcessorUrl = identitySettings.tokenProcessingUri;\r\n//          this.req = new XMLHttpRequest();\r\n            if (identitySettings.version)\r\n                this.version = identitySettings.version;\r\n            else\r\n                this.version = OAuthVersion.v1;\r\n\r\n            this.tokenCache = new TokenCache(identitySettings.tokenStorage);\r\n\r\n            //Callback handler from other windows\r\n            window.addEventListener(\"message\", event => {\r\n                if (event.data.type === \"id_token\") {\r\n                    if (event.data.error) {\r\n                        var e: Error = new Error();\r\n                        e.text = event.data.error;\r\n                        this.loginCallback(e);\r\n\r\n                    } else {\r\n                        //check for state\r\n                        if (this.state !== event.data.state) {\r\n                            var error = new Error();\r\n                            error.statusText = \"Invalid state\";\r\n                            this.loginCallback(error);\r\n                        } else {\r\n                            this.decodeIdToken(event.data.token);\r\n                            this.loginCallback(null);\r\n                        }\r\n                    }\r\n                } else if (event.data.type === \"access_token\") {\r\n                    if (event.data.error) {\r\n                        var e: Error = new Error();\r\n                        e.text = event.data.error;\r\n                        this.getTokenCallback(null, e);\r\n\r\n                    } else {\r\n                        var token:string = event.data.token;\r\n                        var iframe = document.getElementById(\"tokenIFrame\");\r\n                        iframe.parentNode.removeChild(iframe);\r\n\r\n                        if (event.data.state !== this.state) {\r\n                            var error = new Error();\r\n                            error.statusText = \"Invalid state\";\r\n                            this.getTokenCallback(null, error);\r\n                        }\r\n                        else {\r\n                            this.getTokenCallback(token, null);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        public checkForIdentityRedirect(): boolean {\r\n            function token(s: string) {\r\n                var start = window.location.href.indexOf(s);\r\n                if (start < 0) return null;\r\n                var end = window.location.href.indexOf(\"&\",start + s.length);\r\n                return  window.location.href.substring(start,((end > 0) ? end : window.location.href.length));\r\n            }\r\n\r\n            function parseQueryString(str: string) {\r\n                var queryString = str || window.location.search || '';\r\n                var keyValPairs: any[] = [];\r\n                var params: any = {};\r\n                queryString = queryString.replace(/.*?\\?/, \"\");\r\n\r\n                if (queryString.length) {\r\n                    keyValPairs = queryString.split('&');\r\n                    for (var pairNum in keyValPairs) {\r\n                        var key = keyValPairs[pairNum].split('=')[0];\r\n                        if (!key.length) continue;\r\n                        if (typeof params[key] === 'undefined')\r\n                            params[key] = [];\r\n                        params[key].push(keyValPairs[pairNum].split('=')[1]);\r\n                    }\r\n                }\r\n                return params;\r\n            }\r\n\r\n            var params = parseQueryString(window.location.href);\r\n            var idToken = token(\"#id_token=\");\r\n            var accessToken = token(\"#access_token\");\r\n            if (idToken) {\r\n                if (true || this.state === params[\"state\"][0]) { //BUG? When you are in a pure redirect system you don't remember your state or nonce so don't check.\r\n                    this.decodeIdToken(idToken);\r\n                    this.loginCallback && this.loginCallback(null);\r\n                } else {\r\n                    var error = new Error();\r\n                    error.statusText = \"Invalid state\";\r\n                    this.loginCallback && this.loginCallback(error);\r\n                }\r\n                return true;\r\n            }\r\n            else if (accessToken) {\r\n                throw \"Should not get here.  This should be handled via the iframe approach.\"\r\n/*\r\n                if (this.state === params[\"state\"][0]) {\r\n                    this.getTokenCallback && this.getTokenCallback(accessToken, null);\r\n                } else {\r\n                    var error = new Error();\r\n                    error.statusText = \"Invalid state\";\r\n                    this.getTokenCallback && this.getTokenCallback(null, error);\r\n                }\r\n*/\r\n            }\r\n            return false;\r\n        }\r\n\r\n        private decodeIdToken(idToken: string): void {\r\n\r\n            var decodedToken = this.base64Decode(idToken.substring(idToken.indexOf('.') + 1, idToken.lastIndexOf('.')));\r\n            var decodedTokenJSON = JSON.parse(decodedToken);\r\n            var expiryDate = new Date(new Date('01/01/1970 0:0 UTC').getTime() + parseInt(decodedTokenJSON.exp) * 1000);\r\n            this.idToken = new IdToken();\r\n            this.idToken.FullToken = decodedTokenJSON;\r\n            this.idToken.Token = idToken;\r\n            this.idToken.Expiry = expiryDate;\r\n            this.idToken.UPN = decodedTokenJSON.upn;\r\n            this.idToken.TenantId = decodedTokenJSON.tid;\r\n            this.idToken.FamilyName = decodedTokenJSON.family_name;\r\n            this.idToken.GivenName = decodedTokenJSON.given_name;\r\n            this.idToken.Name = decodedTokenJSON.name;\r\n            this.idToken.PreferredUsername = decodedTokenJSON.preferred_username;\r\n\r\n            var expiration: Number = expiryDate.getTime() - new Date().getTime() - 300000;\r\n\r\n            this.refreshTimer = setTimeout((() => {\r\n                this.renewIdToken();\r\n            }), expiration);\r\n        }\r\n\r\n        private decodeAccessToken(accessToken: string, resource?:string, scopes?:string[]): void {\r\n            var decodedToken = this.base64Decode(accessToken.substring(accessToken.indexOf('.') + 1, accessToken.lastIndexOf('.')));\r\n            var decodedTokenJSON = JSON.parse(decodedToken);\r\n            var expiryDate = new Date(new Date('01/01/1970 0:0 UTC').getTime() + parseInt(decodedTokenJSON.exp) * 1000);\r\n            var key = resource || scopes.join(\" \");\r\n\r\n            var token = new CachedToken(key, scopes, resource, accessToken, expiryDate);\r\n            this.tokenCache.add(token);\r\n        }\r\n\r\n        public getIdToken(): any {\r\n            return this.idToken;\r\n        }\r\n        public isLoggedIn(): boolean {\r\n            if (!this.idToken) return false;\r\n            return (this.idToken.Expiry > new Date());\r\n        }\r\n\r\n        private renewIdToken(): void {\r\n            clearTimeout(this.refreshTimer);\r\n            this.login(() => { });\r\n        }\r\n\r\n        public getCurrentOauthVersion(): OAuthVersion {\r\n            return this.version;\r\n        }\r\n\r\n        public getAccessTokenAsync(resource: string): Promise<string,Error> {\r\n\r\n            var d = new Deferred<string,Error>();\r\n            this.getAccessToken(resource, ((error, token) => {\r\n                if (error) {\r\n                    d.reject(error);\r\n                } else {\r\n                    d.resolve(token);\r\n                }\r\n            }));\r\n            return d.promise;\r\n        }\r\n\r\n        public getAccessToken(resource: string, callback: PromiseCallback<string>): void {\r\n            if (this.version !== OAuthVersion.v1) {\r\n                var e = new Error();\r\n                e.statusText = \"Currently this identity class is using v2 OAuth mode. You need to use getAccessTokenForScopes() method\";\r\n                callback(e);\r\n                return;\r\n            }\r\n\r\n            var token = this.tokenCache.getForResource(resource);\r\n            if (token) {\r\n                return callback(null, token.token);\r\n            }\r\n\r\n            //If we got this far, we need to go get this token\r\n\r\n            //Need to create the iFrame to invoke the acquire token\r\n            this.getTokenCallback = ((token: string, error: Error) => {\r\n                if (error) {\r\n                    callback(error);\r\n                }\r\n                else {\r\n                    this.decodeAccessToken(token, resource);\r\n                    callback(null, token);\r\n                }\r\n            });\r\n\r\n            this.nonce = \"token\" + this.generateNonce();\r\n            this.state = \"token\" + this.generateNonce();\r\n\r\n            var iframe = document.createElement('iframe');\r\n            iframe.style.display = \"none\";\r\n            iframe.id = \"tokenIFrame\";\r\n\r\n            iframe.src = this.tokenProcessorUrl + \"?clientId=\" + encodeURIComponent(this.clientId) +\r\n            \"&resource=\" + encodeURIComponent(resource) +\r\n                \"&redirectUri=\" + encodeURIComponent(this.tokenProcessorUrl) +\r\n                \"&state=\" + encodeURIComponent(this.state) +\r\n                \"&version=\" + encodeURIComponent(this.version.toString()) +\r\n                \"&nonce=\" + encodeURIComponent(this.nonce) +\r\n                \"&op=token\";\r\n\r\n            document.body.appendChild(iframe);\r\n        }\r\n\r\n\r\n        public getAccessTokenForScopesAsync(scopes: string[], promptForConsent = false): Promise<string, Error> {\r\n\r\n            var d = new Deferred<string, Error>();\r\n            this.getAccessTokenForScopes(scopes, promptForConsent, (token, error) => {\r\n                if (error) {\r\n                    d.reject(error);\r\n                } else {\r\n                    d.resolve(token);\r\n                }\r\n            });\r\n            return d.promise;\r\n        }\r\n\r\n        public getAccessTokenForScopes(scopes: string[], promptForConsent=false, callback: (token: string, error: Error) => void): void {\r\n            if (this.version !== OAuthVersion.v2) {\r\n                var e = new Error();\r\n                e.statusText = \"Dynamic scopes require v2 mode. Currently this identity class is using v1\";\r\n                callback(null, e);\r\n                return;\r\n            }\r\n\r\n            var token = this.tokenCache.getForScopes(scopes);\r\n            if (token) {\r\n                return callback(token.token, null);\r\n            }\r\n\r\n            //If we got this far, we don't have a valid cached token, so will need to get one.\r\n\r\n            //Need to create the iFrame to invoke the acquire token\r\n\r\n            this.getTokenCallback = ((token: string, error: Error) => {\r\n                if (error) {\r\n                    if (promptForConsent || !error.text) {\r\n                        callback(null, error);\r\n                    } else if (error.text.indexOf(\"AADSTS65001\")>=0) {\r\n                        //We will need to try getting the consent\r\n                        this.getAccessTokenForScopes(scopes, true, this.getTokenCallback);\r\n                    } else {\r\n                        callback(null, error);\r\n                    }\r\n                }\r\n                else {\r\n                    this.decodeAccessToken(token, null, scopes);\r\n                    callback(token, null);\r\n                }\r\n            });\r\n\r\n            this.nonce = \"token\" + this.generateNonce();\r\n            this.state = \"token\" + this.generateNonce();\r\n\r\n            if (!promptForConsent) {\r\n                var iframe = document.createElement('iframe');\r\n                iframe.style.display = \"none\";\r\n                iframe.id = \"tokenIFrame\";\r\n                iframe.src = this.tokenProcessorUrl + \"?clientId=\" + encodeURIComponent(this.clientId) +\r\n                    \"&scopes=\" + encodeURIComponent(scopes.join(\" \")) +\r\n                    \"&redirectUri=\" + encodeURIComponent(this.tokenProcessorUrl) +\r\n                    \"&version=\" + encodeURIComponent(this.version.toString()) +\r\n                    \"&state=\" + encodeURIComponent(this.state) +\r\n                    \"&nonce=\" + encodeURIComponent(this.nonce) +\r\n                    \"&login_hint=\" + encodeURIComponent(this.idToken.PreferredUsername) +\r\n                    \"&domain_hint=\" + encodeURIComponent(this.idToken.TenantId === \"9188040d-6c67-4c5b-b112-36a304b66dad\" ? \"consumers\" : \"organizations\") +\r\n                    \"&op=token\";\r\n                document.body.appendChild(iframe);\r\n            } else {\r\n                window.open(this.tokenProcessorUrl + \"?clientId=\" + encodeURIComponent(this.clientId) +\r\n                    \"&scopes=\" + encodeURIComponent(scopes.join(\" \")) +\r\n                    \"&redirectUri=\" + encodeURIComponent(this.tokenProcessorUrl) +\r\n                    \"&version=\" + encodeURIComponent(this.version.toString()) +\r\n                    \"&state=\" + encodeURIComponent(this.state) +\r\n                    \"&nonce=\" + encodeURIComponent(this.nonce) +\r\n                    \"&op=token\"\r\n                    , \"_blank\");\r\n            }\r\n        }\r\n\r\n        public loginAsync(loginSettings?: { scopes?: string[], policy?:string, tenant?:string}): Promise<void, Error> {\r\n            var d = new Deferred<void, Error>();\r\n            this.login((error) => {\r\n                if (error) {\r\n                    d.reject(error);\r\n                }\r\n                else {\r\n                    d.resolve(null);\r\n                }\r\n            }, loginSettings);\r\n            return d.promise;\r\n        }\r\n\r\n        public login(callback: (error: Error) => void, loginSettings?: { scopes?: string[], policy?: string, tenant?: string}): void {\r\n            this.loginCallback = callback;\r\n            if (!loginSettings) loginSettings = {};\r\n            if (loginSettings.policy) this.policy = loginSettings.policy;\r\n\r\n            if (loginSettings.scopes && this.version === OAuthVersion.v1) {\r\n                var e = new Error();\r\n                e.text = \"Scopes can only be used with OAuth v2.\";\r\n                callback(e);\r\n                return;\r\n            }\r\n\r\n            if (loginSettings.policy && !loginSettings.tenant) {\r\n                var e = new Error();\r\n                e.text = \"In order to use policy (AAD B2C) a tenant must be specified as well.\";\r\n                callback(e);\r\n                return;\r\n            }\r\n            this.state = \"login\" + this.generateNonce();\r\n            this.nonce = \"login\" + this.generateNonce();\r\n            var loginURL = this.tokenProcessorUrl + \"?clientId=\" + encodeURIComponent(this.clientId) +\r\n                \"&redirectUri=\" + encodeURIComponent(this.tokenProcessorUrl) +\r\n                \"&state=\" + encodeURIComponent(this.state) +\r\n                \"&nonce=\" + encodeURIComponent(this.nonce) +\r\n                \"&version=\" + encodeURIComponent(this.version.toString()) +\r\n                \"&op=login\" +\r\n                \"&p=\" + encodeURIComponent(this.policy);\r\n            if (loginSettings.tenant) {\r\n                loginURL += \"&tenant=\" + encodeURIComponent(loginSettings.tenant);\r\n            }\r\n            if (this.version === OAuthVersion.v2) {\r\n                    if (!loginSettings.scopes) loginSettings.scopes = [];\r\n                    if (loginSettings.scopes.indexOf(\"profile\") < 0)\r\n                        loginSettings.scopes.push(\"profile\");\r\n                    if (loginSettings.scopes.indexOf(\"openid\") < 0)\r\n                        loginSettings.scopes.push(\"openid\");\r\n\r\n                    loginURL += \"&scopes=\" + encodeURIComponent(loginSettings.scopes.join(\" \"));\r\n            }\r\n            window.open(loginURL, \"_blank\");\r\n        }\r\n\r\n\r\n        public loginNoWindowAsync(toUrl? : string): Promise<void, Error> {\r\n            var d = new Deferred<void, Error>();\r\n            this.loginNoWindow((error) => {\r\n                if (error) {\r\n                    d.reject(error);\r\n                }\r\n                else {\r\n                    d.resolve(null);\r\n                }\r\n            }, toUrl);\r\n            return d.promise;\r\n        }\r\n\r\n        public loginNoWindow(callback: (error: Error) => void, toUrl? : string): void {\r\n            this.loginCallback = callback;\r\n            this.state = \"clientId=\" + this.clientId + \"&\" + \"tokenProcessorUrl=\" + this.tokenProcessorUrl\r\n            this.nonce = this.generateNonce();\r\n\r\n            var redirected = this.checkForIdentityRedirect();\r\n            if (!redirected) {\r\n                var redirectUri = (toUrl) ? toUrl : window.location.href.split(\"#\")[0];  // default the no login window scenario to return to the current page\r\n                var url = \"https://login.microsoftonline.com/common/oauth2/authorize?response_type=id_token\" +\r\n                    \"&client_id=\" + encodeURIComponent(this.clientId) +\r\n                    \"&redirect_uri=\" + encodeURIComponent(redirectUri) +\r\n                    \"&state=\" + encodeURIComponent(this.state) +\r\n                    \"&nonce=\" + encodeURIComponent(this.nonce);\r\n                window.location.href = url;\r\n            }\r\n        }\r\n\r\n        public logOut(): void {\r\n            this.tokenCache.clear();\r\n            var url = \"https://login.microsoftonline.com/common/oauth2/logout?post_logout_redirect_uri=\" + encodeURI(window.location.href);\r\n            window.location.href = url;\r\n        }\r\n\r\n        private base64Decode(encodedString: string): string {\r\n            var e: any = {}, i: number, b = 0, c: number, x: number, l = 0, a: any, r = '', w = String.fromCharCode, L = encodedString.length;\r\n            var A = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n            for (i = 0; i < 64; i++) { e[A.charAt(i)] = i; }\r\n            for (x = 0; x < L; x++) {\r\n                c = e[encodedString.charAt(x)];\r\n                b = (b << 6) + c;\r\n                l += 6;\r\n                while (l >= 8) {\r\n                    ((a = (b >>> (l -= 8)) & 0xff) || (x < (L - 2))) && (r += w(a));\r\n                }\r\n            }\r\n            return r;\r\n        }\r\n\r\n        private generateNonce(): string {\r\n            var text = \"\";\r\n            var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\r\n            for (var i = 0; i < 32; i++) {\r\n                text += chars.charAt(Math.floor(Math.random() * chars.length));\r\n            }\r\n            return text;\r\n        }\r\n    }\r\n\r\n\r\n//*********************************************************\r\n//\r\n//Kurve js, https://github.com/microsoftdx/kurvejs\r\n//\r\n//Copyright (c) Microsoft Corporation\r\n//All rights reserved.\r\n//\r\n// MIT License:\r\n// Permission is hereby granted, free of charge, to any person obtaining\r\n// a copy of this software and associated documentation files (the\r\n// \"\"Software\"\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to\r\n// permit persons to whom the Software is furnished to do so, subject to\r\n// the following conditions:\r\n\r\n\r\n\r\n\r\n// The above copyright notice and this permission notice shall be\r\n// included in all copies or substantial portions of the Software.\r\n\r\n\r\n\r\n\r\n// THE SOFTWARE IS PROVIDED \"\"AS IS\"\", WITHOUT WARRANTY OF ANY KIND,\r\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n//\r\n//*********************************************************\r\n","// Adapted from the original source: https://github.com/DirtyHairy/typescript-deferred\r\n// Copyright (c) Microsoft. All rights reserved. Licensed under the MIT license. See full license at the bottom of this file.\r\n\r\nimport { Error } from \"./identity\";\r\n\r\n    function DispatchDeferred(closure: () => void) {\r\n        setTimeout(closure, 0);\r\n    }\r\n\r\n    enum PromiseState { Pending, ResolutionInProgress, Resolved, Rejected }\r\n\r\n    export interface PromiseCallback<T> {\r\n        (error: Error, result?: T): void;\r\n    }\r\n\r\n    class Client {\r\n        constructor(\r\n            private _dispatcher: (closure: () => void) => void,\r\n            private _successCB: any,\r\n            private _errorCB: any\r\n        ) {\r\n            this.result = new Deferred<any, any>(_dispatcher);\r\n        }\r\n\r\n        resolve(value: any, defer: boolean): void {\r\n            if (typeof (this._successCB) !== 'function') {\r\n                this.result.resolve(value);\r\n                return;\r\n            }\r\n\r\n            if (defer) {\r\n                this._dispatcher(() => this._dispatchCallback(this._successCB, value));\r\n            } else {\r\n                this._dispatchCallback(this._successCB, value);\r\n            }\r\n        }\r\n\r\n        reject(error: any, defer: boolean): void {\r\n            if (typeof (this._errorCB) !== 'function') {\r\n                this.result.reject(error);\r\n                return;\r\n            }\r\n\r\n            if (defer) {\r\n                this._dispatcher(() => this._dispatchCallback(this._errorCB, error));\r\n            } else {\r\n                this._dispatchCallback(this._errorCB, error);\r\n            }\r\n        }\r\n\r\n        private _dispatchCallback(callback: (arg: any) => any, arg: any): void {\r\n            var result: any,\r\n                then: any,\r\n                type: string;\r\n\r\n            try {\r\n                result = callback(arg);\r\n                this.result.resolve(result);\r\n            } catch (err) {\r\n                this.result.reject(err);\r\n                return;\r\n            }\r\n        }\r\n\r\n        result: Deferred<any, any>;\r\n    }\r\n\r\n    export class Deferred<T, E>  {\r\n        private _dispatcher: (closure: () => void)=> void;\r\n\r\n        constructor();\r\n        constructor(dispatcher: (closure: () => void) => void);\r\n        constructor(dispatcher?: (closure: () => void) => void) {\r\n            if (dispatcher)\r\n                this._dispatcher = dispatcher;\r\n            else\r\n                this._dispatcher = DispatchDeferred;\r\n            this.promise = new Promise<T, E>(this);\r\n        }\r\n\r\n        private DispatchDeferred(closure: () => void) {\r\n            setTimeout(closure, 0);\r\n        }\r\n\r\n        then(successCB: any, errorCB: any): any {\r\n            if (typeof (successCB) !== 'function' && typeof (errorCB) !== 'function') {\r\n                return this.promise;\r\n            }\r\n\r\n            var client = new Client(this._dispatcher, successCB, errorCB);\r\n\r\n            switch (this._state) {\r\n                case PromiseState.Pending:\r\n                case PromiseState.ResolutionInProgress:\r\n                    this._stack.push(client);\r\n                    break;\r\n\r\n                case PromiseState.Resolved:\r\n                    client.resolve(this._value, true);\r\n                    break;\r\n\r\n                case PromiseState.Rejected:\r\n                    client.reject(this._error, true);\r\n                    break;\r\n            }\r\n\r\n            return client.result.promise;\r\n        }\r\n\r\n        resolve(value?: T): Deferred<T, E>;\r\n\r\n        resolve(value?: Promise<T, E>): Deferred<T, E>;\r\n\r\n        resolve(value?: any): Deferred<T, E> {\r\n            if (this._state !== PromiseState.Pending) {\r\n                return this;\r\n            }\r\n\r\n            return this._resolve(value);\r\n        }\r\n\r\n        private _resolve(value: any): Deferred<T, E> {\r\n            var type = typeof (value),\r\n                then: any,\r\n                pending = true;\r\n\r\n            try {\r\n                if (value !== null &&\r\n                    (type === 'object' || type === 'function') &&\r\n                    typeof (then = value.then) === 'function') {\r\n                    if (value === this.promise) {\r\n                        throw new TypeError('recursive resolution');\r\n                    }\r\n\r\n                    this._state = PromiseState.ResolutionInProgress;\r\n                    then.call(value,\r\n                        (result: any): void => {\r\n                            if (pending) {\r\n                                pending = false;\r\n                                this._resolve(result);\r\n                            }\r\n                        },\r\n                        (error: any): void => {\r\n                            if (pending) {\r\n                                pending = false;\r\n                                this._reject(error);\r\n                            }\r\n                        }\r\n                    );\r\n                } else {\r\n                    this._state = PromiseState.ResolutionInProgress;\r\n\r\n                    this._dispatcher(() => {\r\n                        this._state = PromiseState.Resolved;\r\n                        this._value = value;\r\n\r\n                        var i: number,\r\n                            stackSize = this._stack.length;\r\n\r\n                        for (i = 0; i < stackSize; i++) {\r\n                            this._stack[i].resolve(value, false);\r\n                        }\r\n\r\n                        this._stack.splice(0, stackSize);\r\n                    });\r\n                }\r\n            } catch (err) {\r\n                if (pending) {\r\n                    this._reject(err);\r\n                }\r\n            }\r\n\r\n            return this;\r\n        }\r\n\r\n        reject(error?: E): Deferred<T, E> {\r\n            if (this._state !== PromiseState.Pending) {\r\n                return this;\r\n            }\r\n\r\n            return this._reject(error);\r\n        }\r\n\r\n        private _reject(error?: any): Deferred<T, E> {\r\n            this._state = PromiseState.ResolutionInProgress;\r\n\r\n            this._dispatcher(() => {\r\n                this._state = PromiseState.Rejected;\r\n                this._error = error;\r\n\r\n                var stackSize = this._stack.length,\r\n                    i = 0;\r\n\r\n                for (i = 0; i < stackSize; i++) {\r\n                    this._stack[i].reject(error, false);\r\n                }\r\n\r\n                this._stack.splice(0, stackSize);\r\n            });\r\n\r\n            return this;\r\n        }\r\n\r\n        promise: Promise<T, E>;\r\n\r\n        private _stack: Array<Client> = [];\r\n        private _state = PromiseState.Pending;\r\n        private _value: T;\r\n        private _error: any;\r\n    }\r\n\r\n    export class Promise<T, E> implements Promise<T, E> {\r\n        constructor(private _deferred: Deferred<T, E>) { }\r\n\r\n        then<R>(\r\n            successCallback?: (result: T) => R,\r\n            errorCallback?: (error: E) => R\r\n        ): Promise<R, E>;\r\n\r\n        then(successCallback: any, errorCallback: any): any {\r\n            return this._deferred.then(successCallback, errorCallback);\r\n        }\r\n\r\n        fail<R>(\r\n            errorCallback?: (error: E) => R\r\n        ): Promise<R, E>;\r\n\r\n        fail(errorCallback: any): any {\r\n            return this._deferred.then(undefined, errorCallback);\r\n        }\r\n    }\r\n\r\n//*********************************************************\r\n//\r\n//Kurve js, https://github.com/microsoftdx/kurvejs\r\n//\r\n//Copyright (c) Microsoft Corporation\r\n//All rights reserved.\r\n//\r\n// MIT License:\r\n// Permission is hereby granted, free of charge, to any person obtaining\r\n// a copy of this software and associated documentation files (the\r\n// \"\"Software\"\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to\r\n// permit persons to whom the Software is furnished to do so, subject to\r\n// the following conditions:\r\n\r\n\r\n\r\n\r\n// The above copyright notice and this permission notice shall be\r\n// included in all copies or substantial portions of the Software.\r\n\r\n\r\n\r\n\r\n// THE SOFTWARE IS PROVIDED \"\"AS IS\"\", WITHOUT WARRANTY OF ANY KIND,\r\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n//\r\n//*********************************************************\r\n","// Copyright (c) Microsoft. All rights reserved. Licensed under the MIT license. See full license at the bottom of this file.\r\n\r\nimport { Deferred, Promise, PromiseCallback } from \"./promises\";\r\nimport { Identity, OAuthVersion, Error } from \"./identity\";\r\nimport { UserDataModel, ProfilePhotoDataModel, MessageDataModel, EventDataModel, GroupDataModel, MailFolderDataModel, AttachmentDataModel } from \"./models\"\r\n\r\n    export module Scopes {\r\n        class Util {\r\n            static rootUrl = \"https://graph.microsoft.com/\";\r\n        }\r\n        export class General {\r\n            public static OpenId: string = \"openid\";\r\n            public static OfflineAccess: string = \"offline_access\";\r\n        }\r\n        export class User {\r\n            public static Read: string = Util.rootUrl + \"User.Read\";\r\n            public static ReadWrite: string = Util.rootUrl + \"User.ReadWrite\";\r\n            public static ReadBasicAll: string = Util.rootUrl + \"User.ReadBasic.All\";\r\n            public static ReadAll: string = Util.rootUrl + \"User.Read.All\";\r\n            public static ReadWriteAll: string = Util.rootUrl + \"User.ReadWrite.All\";\r\n        }\r\n        export class Contacts {\r\n            public static Read: string = Util.rootUrl + \"Contacts.Read\";\r\n            public static ReadWrite: string = Util.rootUrl + \"Contacts.ReadWrite\";\r\n        }\r\n        export class Directory {\r\n            public static ReadAll: string = Util.rootUrl + \"Directory.Read.All\";\r\n            public static ReadWriteAll: string = Util.rootUrl + \"Directory.ReadWrite.All\";\r\n            public static AccessAsUserAll: string = Util.rootUrl + \"Directory.AccessAsUser.All\";\r\n        }\r\n        export class Group {\r\n            public static ReadAll: string = Util.rootUrl + \"Group.Read.All\";\r\n            public static ReadWriteAll: string = Util.rootUrl + \"Group.ReadWrite.All\";\r\n            public static AccessAsUserAll: string = Util.rootUrl + \"Directory.AccessAsUser.All\";\r\n        }\r\n        export class Mail {\r\n            public static Read: string = Util.rootUrl + \"Mail.Read\";\r\n            public static ReadWrite: string = Util.rootUrl + \"Mail.ReadWrite\";\r\n            public static Send: string = Util.rootUrl + \"Mail.Send\";\r\n        }\r\n        export class Calendars {\r\n            public static Read: string = Util.rootUrl + \"Calendars.Read\";\r\n            public static ReadWrite: string = Util.rootUrl + \"Calendars.ReadWrite\";\r\n        }\r\n        export class Files {\r\n            public static Read: string = Util.rootUrl + \"Files.Read\";\r\n            public static ReadAll: string = Util.rootUrl + \"Files.Read.All\";\r\n            public static ReadWrite: string = Util.rootUrl + \"Files.ReadWrite\";\r\n            public static ReadWriteAppFolder: string = Util.rootUrl + \"Files.ReadWrite.AppFolder\";\r\n            public static ReadWriteSelected: string = Util.rootUrl + \"Files.ReadWrite.Selected\";\r\n        }\r\n        export class Tasks {\r\n            public static ReadWrite: string = Util.rootUrl + \"Tasks.ReadWrite\";\r\n        }\r\n        export class People {\r\n            public static Read: string = Util.rootUrl + \"People.Read\";\r\n            public static ReadWrite: string = Util.rootUrl + \"People.ReadWrite\";\r\n        }\r\n        export class Notes {\r\n            public static Create: string = Util.rootUrl + \"Notes.Create\";\r\n            public static ReadWriteCreatedByApp: string = Util.rootUrl + \"Notes.ReadWrite.CreatedByApp\";\r\n            public static Read: string = Util.rootUrl + \"Notes.Read\";\r\n            public static ReadAll: string = Util.rootUrl + \"Notes.Read.All\";\r\n            public static ReadWriteAll: string = Util.rootUrl + \"Notes.ReadWrite.All\";\r\n        }\r\n    }\r\n\r\n    export class DataModelWrapper<T> {\r\n        constructor(protected graph: Graph, protected _data: T) {\r\n        }\r\n        get data() { return this._data; }\r\n    }\r\n\r\n    export class DataModelListWrapper<T,S> extends DataModelWrapper<T[]>{\r\n        public nextLink: NextLink<S>;\r\n    }\r\n\r\n    export class ProfilePhoto extends DataModelWrapper<ProfilePhotoDataModel> {\r\n    }\r\n\r\n    export enum EventsEndpoint { events, calendarView }\r\n\r\n    export class User extends DataModelWrapper<UserDataModel> {\r\n        // These are all passthroughs to the graph\r\n\r\n        public events(callback: PromiseCallback<Events>, odataQuery?: string) {\r\n            this.graph.eventsForUser(this._data.userPrincipalName, EventsEndpoint.events, callback, odataQuery);\r\n        }\r\n\r\n        public eventsAsync(odataQuery?: string): Promise<Events, Error> {\r\n            return this.graph.eventsForUserAsync(this._data.userPrincipalName, EventsEndpoint.events, odataQuery);\r\n        }\r\n\r\n        public memberOf(callback: PromiseCallback<Groups>, Error, odataQuery?: string) {\r\n            this.graph.memberOfForUser(this._data.userPrincipalName, callback, odataQuery);\r\n        }\r\n\r\n        public memberOfAsync(odataQuery?: string): Promise<Groups, Error> {\r\n            return this.graph.memberOfForUserAsync(this._data.userPrincipalName, odataQuery);\r\n        }\r\n\r\n        public messages(callback: PromiseCallback<Messages>, odataQuery?: string) {\r\n            this.graph.messagesForUser(this._data.userPrincipalName, callback, odataQuery);\r\n        }\r\n\r\n        public messagesAsync(odataQuery?: string): Promise<Messages, Error> {\r\n            return this.graph.messagesForUserAsync(this._data.userPrincipalName, odataQuery);\r\n        }\r\n\r\n        public manager(callback: PromiseCallback<User>, odataQuery?: string) {\r\n            this.graph.managerForUser(this._data.userPrincipalName, callback, odataQuery);\r\n        }\r\n\r\n        public managerAsync(odataQuery?: string): Promise<User, Error> {\r\n            return this.graph.managerForUserAsync(this._data.userPrincipalName, odataQuery);\r\n        }\r\n\r\n        public profilePhoto(callback: PromiseCallback<ProfilePhoto>, odataQuery?: string) {\r\n            this.graph.profilePhotoForUser(this._data.userPrincipalName, callback, odataQuery);\r\n        }\r\n\r\n        public profilePhotoAsync(odataQuery?: string): Promise<ProfilePhoto, Error> {\r\n            return this.graph.profilePhotoForUserAsync(this._data.userPrincipalName, odataQuery);\r\n        }\r\n\r\n        public profilePhotoValue(callback: PromiseCallback<any>, odataQuery?: string) {\r\n            this.graph.profilePhotoValueForUser(this._data.userPrincipalName, callback, odataQuery);\r\n        }\r\n\r\n        public profilePhotoValueAsync(odataQuery?: string): Promise<any, Error> {\r\n            return this.graph.profilePhotoValueForUserAsync(this._data.userPrincipalName, odataQuery);\r\n        }\r\n\r\n        public calendarView(callback: PromiseCallback<Events>, odataQuery?: string) {\r\n            this.graph.eventsForUser(this._data.userPrincipalName, EventsEndpoint.calendarView, callback, odataQuery);\r\n        }\r\n\r\n        public calendarViewAsync(odataQuery?: string): Promise<Events, Error> {\r\n            return this.graph.eventsForUserAsync(this._data.userPrincipalName, EventsEndpoint.calendarView, odataQuery);\r\n        }\r\n\r\n        public mailFolders(callback: PromiseCallback<MailFolders>, odataQuery?: string) {\r\n            this.graph.mailFoldersForUser(this._data.userPrincipalName, callback, odataQuery);\r\n        }\r\n\r\n        public mailFoldersAsync(odataQuery?: string): Promise<MailFolders, Error> {\r\n            return this.graph.mailFoldersForUserAsync(this._data.userPrincipalName, odataQuery);\r\n        }\r\n\r\n        public message(messageId: string, callback: PromiseCallback<Message>, odataQuery?: string) {\r\n            this.graph.messageForUser(this._data.userPrincipalName, messageId, callback, odataQuery);\r\n        }\r\n\r\n        public messageAsync(messageId: string, odataQuery?: string): Promise<Message, Error> {\r\n            return this.graph.messageForUserAsync(this._data.userPrincipalName, messageId, odataQuery);\r\n        }\r\n\r\n        public event(eventId: string, callback: PromiseCallback<Event>, odataQuery?: string) {\r\n            this.graph.eventForUser(this._data.userPrincipalName, eventId, callback, odataQuery);\r\n        }\r\n\r\n        public eventAsync(eventId: string, odataQuery?: string): Promise<Event, Error> {\r\n            return this.graph.eventForUserAsync(this._data.userPrincipalName, eventId, odataQuery);\r\n        }\r\n\r\n\r\n        public messageAttachment(messageId: string, attachmentId: string, callback: PromiseCallback<Attachment>, odataQuery?: string) {\r\n            this.graph.messageAttachmentForUser(this._data.userPrincipalName, messageId, attachmentId, callback, odataQuery);\r\n        }\r\n\r\n        public messageAttachmentAsync(messageId: string, attachmentId: string, odataQuery?: string): Promise<Attachment, Error> {\r\n            return this.graph.messageAttachmentForUserAsync(this._data.userPrincipalName, messageId, attachmentId, odataQuery);\r\n        }\r\n\r\n\r\n    }\r\n\r\n    export interface NextLink<T> {\r\n        (callback? : PromiseCallback<T>): Promise<T, Error>;\r\n    }\r\n\r\n    export class Users extends DataModelListWrapper<User, Users>{\r\n    }\r\n\r\n    export class Message extends DataModelWrapper<MessageDataModel>{\r\n    }\r\n\r\n    export class Messages extends DataModelListWrapper<Message, Messages>{\r\n    }\r\n\r\n    export class Event extends DataModelWrapper<EventDataModel>{\r\n    }\r\n\r\n    export class Events extends DataModelListWrapper<Event, Events>{\r\n        constructor(protected graph: Graph, protected endpoint: EventsEndpoint, protected _data: Event[]) {\r\n            super(graph, _data);\r\n        }\r\n    }\r\n\r\n    export class Contact {\r\n    }\r\n\r\n    export class Group extends DataModelWrapper<GroupDataModel>{\r\n    }\r\n\r\n    export class Groups extends DataModelListWrapper<Group, Groups>{\r\n    }\r\n\r\n    export class MailFolder extends DataModelWrapper<MailFolderDataModel>{\r\n    }\r\n\r\n    export class MailFolders extends DataModelListWrapper<MailFolder, MailFolders>{\r\n    }\r\n\r\n\texport enum AttachmentType {\r\n\t\tfileAttachment,\r\n\t\titemAttachment,\r\n\t\treferenceAttachment\r\n\t}\r\n\r\n    export class Attachment extends DataModelWrapper<AttachmentDataModel>{\r\n        public getType() : AttachmentType {\r\n            switch (this._data['@odata.type']) {\r\n                case \"#microsoft.graph.fileAttachment\":\r\n                    return AttachmentType.fileAttachment;\r\n                case \"#microsoft.graph.itemAttachment\":\r\n                    return AttachmentType.itemAttachment;\r\n                case \"#microsoft.graph.referenceAttachment\":\r\n                    return AttachmentType.referenceAttachment;\r\n            }\r\n        }\r\n    }\r\n\r\n    export class Attachments extends DataModelListWrapper<Attachment, Attachments>{\r\n    }\r\n\r\n    export class Graph {\r\n        private req: XMLHttpRequest = null;\r\n        private accessToken: string = null;\r\n        private KurveIdentity: Identity = null;\r\n        private defaultResourceID: string = \"https://graph.microsoft.com\";\r\n        private baseUrl: string = \"https://graph.microsoft.com/v1.0/\";\r\n\r\n        constructor(identityInfo: { identity: Identity });\r\n        constructor(identityInfo: { defaultAccessToken: string });\r\n        constructor(identityInfo: any) {\r\n            if (identityInfo.defaultAccessToken) {\r\n                this.accessToken = identityInfo.defaultAccessToken;\r\n            } else {\r\n                this.KurveIdentity = identityInfo.identity;\r\n            }\r\n        }\r\n\r\n        //Only adds scopes when linked to a v2 Oauth of kurve identity\r\n        private scopesForV2(scopes: string[]): string[] {\r\n            if (!this.KurveIdentity)\r\n                return null;\r\n            if (this.KurveIdentity.getCurrentOauthVersion() === OAuthVersion.v1)\r\n                return null;\r\n            else return scopes;\r\n        }\r\n\r\n        //Users\r\n        public meAsync(odataQuery?: string): Promise<User, Error> {\r\n            var d = new Deferred<User,Error>();\r\n            this.me((error, user) => error ? d.reject(error) : d.resolve(user), odataQuery);\r\n            return d.promise;\r\n        }\r\n\r\n        public me(callback: PromiseCallback<User>, odataQuery?: string): void {\r\n            var scopes = [Scopes.User.Read];\r\n            var urlString = this.buildMeUrl(\"\", odataQuery);\r\n            this.getUser(urlString, callback, this.scopesForV2(scopes));\r\n        }\r\n\r\n        public userAsync(userId: string, odataQuery?: string, basicProfileOnly = true): Promise<User, Error> {\r\n            var d = new Deferred<User,Error>();\r\n            this.user(userId, (error, user) => error ? d.reject(error) : d.resolve(user), odataQuery, basicProfileOnly);\r\n            return d.promise;\r\n        }\r\n\r\n        public user(userId: string, callback: PromiseCallback<User>, odataQuery?: string, basicProfileOnly = true): void {\r\n            var scopes = basicProfileOnly ? [Scopes.User.ReadBasicAll] : [Scopes.User.ReadAll];\r\n            var urlString = this.buildUsersUrl(userId, odataQuery);\r\n            this.getUser(urlString, callback, this.scopesForV2(scopes));\r\n        }\r\n\r\n        public usersAsync(odataQuery?: string, basicProfileOnly = true): Promise<Users, Error> {\r\n            var d = new Deferred<Users,Error>();\r\n            this.users((error, users) => error ? d.reject(error) : d.resolve(users), odataQuery, basicProfileOnly);\r\n            return d.promise;\r\n        }\r\n\r\n        public users(callback: PromiseCallback<Users>, odataQuery?: string, basicProfileOnly = true): void {\r\n            var scopes = basicProfileOnly ? [Scopes.User.ReadBasicAll] : [Scopes.User.ReadAll];\r\n            var urlString = this.buildUsersUrl(\"\", odataQuery);\r\n            this.getUsers(urlString, callback, this.scopesForV2(scopes), basicProfileOnly);\r\n        }\r\n\r\n        //Groups\r\n        public groupAsync(groupId: string, odataQuery?: string): Promise<Group,Error> {\r\n            var d = new Deferred<Group,Error>();\r\n            this.group(groupId, (error, group) => error ? d.reject(error) : d.resolve(group), odataQuery);\r\n            return d.promise;\r\n        }\r\n\r\n        public group(groupId: string, callback: PromiseCallback<Group>, odataQuery?: string): void {\r\n            var scopes = [Scopes.Group.ReadAll];\r\n            var urlString = this.buildGroupsUrl(groupId, odataQuery);\r\n            this.getGroup(urlString, callback, this.scopesForV2(scopes));\r\n        }\r\n\r\n        public groupsAsync(odataQuery?: string): Promise<Groups, Error> {\r\n            var d = new Deferred<Groups, Error>();\r\n            this.groups((error, groups) => error ? d.reject(error) : d.resolve(groups), odataQuery);\r\n            return d.promise;\r\n        }\r\n\r\n        public groups(callback: PromiseCallback<Groups>, odataQuery?: string): void {\r\n            var scopes = [Scopes.Group.ReadAll];\r\n            var urlString = this.buildGroupsUrl(\"\", odataQuery);\r\n            this.getGroups(urlString, callback, this.scopesForV2(scopes));\r\n        }\r\n\r\n        // Messages For User\r\n        public messageForUserAsync(userPrincipalName: string, messageId: string, odataQuery?: string): Promise<Message, Error> {\r\n            var d = new Deferred<Message, Error>();\r\n            this.messageForUser(userPrincipalName, messageId, (error, message) => error ? d.reject(error) : d.resolve(message), odataQuery);\r\n            return d.promise;\r\n        }\r\n\r\n        public messageForUser(userPrincipalName: string, messageId: string, callback: PromiseCallback<Message>, odataQuery?: string): void {\r\n            var scopes = [Scopes.Mail.Read];\r\n            var urlString = this.buildUsersUrl(userPrincipalName + \"/messages/\" + messageId, odataQuery);\r\n            this.getMessage(urlString, messageId, (error, result) => callback(error, result), this.scopesForV2(scopes));\r\n        }\r\n\r\n        public messagesForUserAsync(userPrincipalName: string, odataQuery?: string): Promise<Messages, Error> {\r\n            var d = new Deferred<Messages, Error>();\r\n            this.messagesForUser(userPrincipalName, (error, messages) => error ? d.reject(error) : d.resolve(messages), odataQuery);\r\n            return d.promise;\r\n        }\r\n\r\n        public messagesForUser(userPrincipalName: string, callback: PromiseCallback<Messages>, odataQuery?: string): void {\r\n            var scopes = [Scopes.Mail.Read];\r\n            var urlString = this.buildUsersUrl(userPrincipalName + \"/messages\", odataQuery);\r\n            this.getMessages(urlString, (error, result) => callback(error, result), this.scopesForV2(scopes));\r\n        }\r\n\r\n        // MailFolders For User\r\n        public mailFoldersForUserAsync(userPrincipalName: string, odataQuery?: string): Promise<MailFolders, Error> {\r\n            var d = new Deferred<MailFolders, Error>();\r\n            this.mailFoldersForUser(userPrincipalName, (error, messages) => error ? d.reject(error) : d.resolve(messages), odataQuery);\r\n            return d.promise;\r\n        }\r\n\r\n        public mailFoldersForUser(userPrincipalName: string, callback: PromiseCallback<MailFolders>, odataQuery?: string): void {\r\n            var scopes = [Scopes.Mail.Read];\r\n            var urlString = this.buildUsersUrl(userPrincipalName + \"/mailFolders\", odataQuery);\r\n            this.getMailFolders(urlString, (error, result) => callback(error, result), this.scopesForV2(scopes));\r\n        }\r\n\r\n        // Events For User\r\n\r\n        public eventForUserAsync(userPrincipalName: string, eventId: string, odataQuery?: string): Promise<Event, Error> {\r\n            var d = new Deferred<Event, Error>();\r\n            this.eventForUser(userPrincipalName, eventId, (error, event) => error ? d.reject(error) : d.resolve(event), odataQuery);\r\n            return d.promise;\r\n        }\r\n\r\n        public eventForUser(userPrincipalName: string, eventId: string, callback: PromiseCallback<Event>, odataQuery?: string): void {\r\n            var scopes = [Scopes.Calendars.Read];\r\n            var urlString = this.buildUsersUrl(userPrincipalName + \"/events/\" + eventId, odataQuery);\r\n            this.getEvent(urlString, eventId, (error, result) => callback(error, result), this.scopesForV2(scopes));\r\n        }\r\n\r\n        public eventsForUserAsync(userPrincipalName: string, endpoint: EventsEndpoint, odataQuery?: string): Promise<Events, Error> {\r\n            var d = new Deferred<Events, Error>();\r\n            this.eventsForUser(userPrincipalName, endpoint, (error, events) => error ? d.reject(error) : d.resolve(events), odataQuery);\r\n            return d.promise;\r\n        }\r\n\r\n        public eventsForUser(userPrincipalName: string, endpoint: EventsEndpoint, callback: (error: Error, messages: Events) => void, odataQuery?: string): void {\r\n            var scopes = [Scopes.Calendars.Read];\r\n            var urlString = this.buildUsersUrl(userPrincipalName + \"/\" + EventsEndpoint[endpoint], odataQuery);\r\n            this.getEvents(urlString, endpoint, (error, result) => callback(error, result), this.scopesForV2(scopes));\r\n        }\r\n\r\n        // Groups/Relationships For User\r\n        public memberOfForUserAsync(userPrincipalName: string, odataQuery?: string): Promise<Groups, Error> {\r\n            var d = new Deferred<Groups, Error>();\r\n            this.memberOfForUser(userPrincipalName, (error, groups) => error ? d.reject(error) : d.resolve(groups), odataQuery);\r\n            return d.promise;\r\n        }\r\n\r\n        public memberOfForUser(userPrincipalName: string, callback: PromiseCallback<Groups>, odataQuery?: string) {\r\n            var scopes = [Scopes.Group.ReadAll];\r\n            var urlString = this.buildUsersUrl(userPrincipalName + \"/memberOf\", odataQuery);\r\n            this.getGroups(urlString, callback, this.scopesForV2(scopes));\r\n        }\r\n\r\n        public managerForUserAsync(userPrincipalName: string, odataQuery?: string): Promise<User, Error> {\r\n            var d = new Deferred<User, Error>();\r\n            this.managerForUser(userPrincipalName, (error, user) => error ? d.reject(error) : d.resolve(user), odataQuery);\r\n            return d.promise;\r\n        }\r\n\r\n        public managerForUser(userPrincipalName: string, callback: PromiseCallback<User>, odataQuery?: string) {\r\n            var scopes = [Scopes.Directory.ReadAll];\r\n            var urlString = this.buildUsersUrl(userPrincipalName + \"/manager\", odataQuery);\r\n            this.getUser(urlString, callback, this.scopesForV2(scopes));\r\n        }\r\n\r\n        public directReportsForUserAsync(userPrincipalName: string, odataQuery?: string): Promise<Users, Error> {\r\n            var d = new Deferred<Users, Error>();\r\n            this.directReportsForUser(userPrincipalName, (error, users) => error ? d.reject(error) : d.resolve(users), odataQuery);\r\n            return d.promise;\r\n        }\r\n\r\n        public directReportsForUser(userPrincipalName: string, callback: PromiseCallback<Users>, odataQuery?: string) {\r\n            var scopes = [Scopes.Directory.ReadAll];\r\n            var urlString = this.buildUsersUrl(userPrincipalName + \"/directReports\", odataQuery);\r\n            this.getUsers(urlString, callback, this.scopesForV2(scopes));\r\n        }\r\n\r\n        public profilePhotoForUserAsync(userPrincipalName: string, odataQuery?: string): Promise<ProfilePhoto, Error> {\r\n            var d = new Deferred<ProfilePhoto, Error>();\r\n            this.profilePhotoForUser(userPrincipalName, (error, profilePhoto) => error ? d.reject(error) : d.resolve(profilePhoto), odataQuery);\r\n            return d.promise;\r\n        }\r\n\r\n        public profilePhotoForUser(userPrincipalName: string, callback: PromiseCallback<ProfilePhoto>, odataQuery?: string) {\r\n            var scopes = [Scopes.User.ReadBasicAll];\r\n            var urlString = this.buildUsersUrl(userPrincipalName + \"/photo\", odataQuery);\r\n            this.getPhoto(urlString, callback, this.scopesForV2(scopes));\r\n        }\r\n\r\n        public profilePhotoValueForUserAsync(userPrincipalName: string, odataQuery?: string): Promise<any, Error> {\r\n            var d = new Deferred<any, Error>();\r\n            this.profilePhotoValueForUser(userPrincipalName, (error, result) => error ? d.reject(error) : d.resolve(result), odataQuery);\r\n            return d.promise;\r\n        }\r\n\r\n        public profilePhotoValueForUser(userPrincipalName: string, callback: PromiseCallback<any>, odataQuery?: string) {\r\n            var scopes = [Scopes.User.ReadBasicAll];\r\n            var urlString = this.buildUsersUrl(userPrincipalName + \"/photo/$value\", odataQuery);\r\n            this.getPhotoValue(urlString, callback, this.scopesForV2(scopes));\r\n        }\r\n\r\n        // Message Attachments\r\n        public messageAttachmentsForUserAsync(userPrincipalName: string, messageId: string, odataQuery?: string): Promise<Attachments, Error> {\r\n            var d = new Deferred<any, Error>();\r\n            this.messageAttachmentsForUser(userPrincipalName, messageId, (error, result) => error ? d.reject(error) : d.resolve(result), odataQuery);\r\n            return d.promise;\r\n        }\r\n\r\n        public messageAttachmentsForUser(userPrincipalName: string, messageId: string, callback: PromiseCallback<Attachments>, odataQuery?: string): void {\r\n            var scopes = [Scopes.Mail.Read];\r\n            var urlString = this.buildUsersUrl(userPrincipalName + \"/messages/\" + messageId + \"/attachments\", odataQuery);\r\n            this.getMessageAttachments(urlString, callback, this.scopesForV2(scopes));\r\n        }\r\n\r\n        public messageAttachmentForUserAsync(userPrincipalName: string, messageId: string, attachmentId: string, odataQuery?: string): Promise<Attachment, Error> {\r\n            var d = new Deferred<Attachment,Error>();\r\n            this.messageAttachmentForUser(userPrincipalName, messageId, attachmentId, (error, attachment) => error ? d.reject(error) : d.resolve(attachment), odataQuery);\r\n            return d.promise;\r\n        }\r\n\r\n        public messageAttachmentForUser(userPrincipalName: string, messageId: string, attachmentId: string, callback: PromiseCallback<Attachment>, odataQuery?: string): void {\r\n            var scopes = [Scopes.Mail.Read];\r\n            var urlString = this.buildUsersUrl(userPrincipalName + \"/messages/\" + messageId + \"/attachments/\" + attachmentId, odataQuery);\r\n            this.getMessageAttachment(urlString, callback, this.scopesForV2(scopes));\r\n        }\r\n\r\n        //http verbs\r\n        public getAsync(url: string): Promise<string, Error> {\r\n            var d = new Deferred<string,Error>();\r\n            this.get(url, (error, response) => error ? d.reject(error) : d.resolve(response))\r\n            return d.promise;\r\n        }\r\n\r\n        public get(url: string, callback: PromiseCallback<string>, responseType?: string, scopes?:string[]): void {\r\n            var xhr = new XMLHttpRequest();\r\n            if (responseType)\r\n                xhr.responseType = responseType;\r\n            xhr.onreadystatechange = () => {\r\n                if (xhr.readyState === 4)\r\n                    if (xhr.status === 200)\r\n                        callback(null, responseType ? xhr.response : xhr.responseText);\r\n                    else\r\n                        callback(this.generateError(xhr));\r\n            }\r\n\r\n            xhr.open(\"GET\", url);\r\n            this.addAccessTokenAndSend(xhr, (addTokenError: Error) => {\r\n                if (addTokenError) {\r\n                    callback(addTokenError);\r\n                }\r\n            }, scopes);\r\n        }\r\n\r\n        private generateError(xhr: XMLHttpRequest): Error {\r\n            var response = new Error();\r\n            response.status = xhr.status;\r\n            response.statusText = xhr.statusText;\r\n            if (xhr.responseType === '' || xhr.responseType === 'text')\r\n                response.text = xhr.responseText;\r\n            else\r\n                response.other = xhr.response;\r\n            return response;\r\n\r\n        }\r\n\r\n        //Private methods\r\n\r\n        private getUsers(urlString, callback: PromiseCallback<Users>, scopes?: string[], basicProfileOnly = true): void {\r\n            this.get(urlString, (errorGet: Error, result: string) => {\r\n                if (errorGet) {\r\n                    callback(errorGet);\r\n                    return;\r\n                }\r\n\r\n                var usersODATA = JSON.parse(result);\r\n                if (usersODATA.error) {\r\n                    var errorODATA = new Error();\r\n                    errorODATA.other = usersODATA.error;\r\n                    callback(errorODATA);\r\n                    return;\r\n                }\r\n\r\n                var resultsArray = (usersODATA.value ? usersODATA.value : [usersODATA]) as any[];\r\n                var users = new Users(this, resultsArray.map(o => new User(this, o)));\r\n                var nextLink = usersODATA['@odata.nextLink'];\r\n                if (nextLink) {\r\n                    users.nextLink = (callback?: PromiseCallback<Users>) => {\r\n                        var scopes = basicProfileOnly ? [Scopes.User.ReadBasicAll] : [Scopes.User.ReadAll];\r\n                        var d = new Deferred<Users,Error>();\r\n                        this.getUsers(nextLink, (error: Error, result: Users) => {\r\n                            if (callback)\r\n                                callback(error, result);\r\n                            else\r\n                                error ? d.reject(error) : d.resolve(result);\r\n                        }, this.scopesForV2(scopes), basicProfileOnly);\r\n                        return d.promise;\r\n                    }\r\n                }\r\n\r\n                callback(null, users);\r\n            },null,scopes);\r\n        }\r\n\r\n        private getUser(urlString, callback: PromiseCallback<User>, scopes?:string[]): void {\r\n            this.get(urlString, (errorGet: Error, result: string) => {\r\n                if (errorGet) {\r\n                    callback(errorGet);\r\n                    return;\r\n                }\r\n                var userODATA = JSON.parse(result) ;\r\n                if (userODATA.error) {\r\n                    var errorODATA = new Error();\r\n                    errorODATA.other = userODATA.error;\r\n                    callback(errorODATA);\r\n                    return;\r\n                }\r\n\r\n                var user = new User(this, userODATA);\r\n                callback(null, user);\r\n            },null,scopes);\r\n\r\n        }\r\n\r\n        private addAccessTokenAndSend(xhr: XMLHttpRequest, callback: (error: Error) => void, scopes?:string[]): void {\r\n            if (this.accessToken) {\r\n                //Using default access token\r\n                xhr.setRequestHeader('Authorization', 'Bearer ' + this.accessToken);\r\n                xhr.send();\r\n            } else {\r\n                //Using the integrated Identity object\r\n\r\n                if (scopes) {\r\n                    //v2 scope based tokens\r\n                    this.KurveIdentity.getAccessTokenForScopes(scopes,false, ((token: string, error: Error) => {\r\n                        if (error)\r\n                            callback(error);\r\n                        else {\r\n                            xhr.setRequestHeader('Authorization', 'Bearer ' + token);\r\n                            xhr.send();\r\n                            callback(null);\r\n                        }\r\n                    }));\r\n\r\n                }\r\n                else {\r\n                    //v1 resource based tokens\r\n                    this.KurveIdentity.getAccessToken(this.defaultResourceID, ((error: Error, token: string) => {\r\n                        if (error)\r\n                            callback(error);\r\n                        else {\r\n                            xhr.setRequestHeader('Authorization', 'Bearer ' + token);\r\n                            xhr.send();\r\n                            callback(null);\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n        }\r\n\r\n        private getMessage(urlString: string, messageId: string, callback: PromiseCallback<Message>, scopes?:string[]): void {\r\n            this.get(urlString, (errorGet: Error, result: string) => {\r\n                if (errorGet) {\r\n                    callback(errorGet);\r\n                    return;\r\n                }\r\n                var ODATA = JSON.parse(result);\r\n                if (ODATA.error) {\r\n                    var ODATAError = new Error();\r\n                    ODATAError.other = ODATA.error;\r\n                    callback(ODATAError);\r\n                    return;\r\n                }\r\n                var message = new Message(this, ODATA);\r\n\r\n                callback(null, message);\r\n            }, null, scopes);\r\n\r\n        }\r\n\r\n        private getMessages(urlString: string, callback: PromiseCallback<Messages>, scopes?:string[]): void {\r\n            this.get(urlString, (errorGet: Error, result: string) => {\r\n                if (errorGet) {\r\n                    callback(errorGet);\r\n                    return;\r\n                }\r\n\r\n                var messagesODATA = JSON.parse(result);\r\n                if (messagesODATA.error) {\r\n                    var errorODATA = new Error();\r\n                    errorODATA.other = messagesODATA.error;\r\n                    callback(errorODATA);\r\n                    return;\r\n                }\r\n\r\n                var resultsArray = (messagesODATA.value ? messagesODATA.value : [messagesODATA]) as any[];\r\n                var messages = new Messages(this, resultsArray.map(o => new Message(this, o)));\r\n                var nextLink = messagesODATA['@odata.nextLink'];\r\n                if (nextLink) {\r\n                    messages.nextLink = (callback?: PromiseCallback<Messages>) => {\r\n                        var scopes = [Scopes.Mail.Read];\r\n                        var d = new Deferred<Messages,Error>();\r\n                        this.getMessages(nextLink, (error: Error, messages: Messages) => {\r\n                            if (callback)\r\n                                callback(error, messages);\r\n                            else\r\n                                error ? d.reject(error) : d.resolve(messages);\r\n                        }, this.scopesForV2(scopes));\r\n                        return d.promise;\r\n                    }\r\n                }\r\n                callback(null, messages);\r\n            },null,scopes);\r\n        }\r\n\r\n        private getEvent(urlString: string, EventId: string, callback: PromiseCallback<Event>, scopes?:string[]): void {\r\n            this.get(urlString, (errorGet: Error, result: string) => {\r\n                if (errorGet) {\r\n                    callback(errorGet);\r\n                    return;\r\n                }\r\n                var ODATA = JSON.parse(result);\r\n                if (ODATA.error) {\r\n                    var ODATAError = new Error();\r\n                    ODATAError.other = ODATA.error;\r\n                    callback(ODATAError);\r\n                    return;\r\n                }\r\n                var event = new Event(this, ODATA);\r\n\r\n                callback(null, event);\r\n            }, null, scopes);\r\n\r\n        }\r\n\r\n        private getEvents(urlString: string, endpoint: EventsEndpoint, callback: PromiseCallback<Events>, scopes?: string[]): void {\r\n            this.get(urlString, (errorGet: Error, result: string) => {\r\n                if (errorGet) {\r\n                    callback(errorGet);\r\n                    return;\r\n                }\r\n\r\n                var odata = JSON.parse(result);\r\n                if (odata.error) {\r\n                    var errorODATA = new Error();\r\n                    errorODATA.other = odata.error;\r\n                    callback(errorODATA);\r\n                    return;\r\n                }\r\n\r\n                var resultsArray = (odata.value ? odata.value : [odata]) as any[];\r\n                var events = new Events(this, endpoint, resultsArray.map(o => new Event(this, o)));\r\n                var nextLink = odata['@odata.nextLink'];\r\n                if (nextLink) {\r\n                    events.nextLink = (callback?: PromiseCallback<Events>) => {\r\n                        var scopes = [Scopes.Mail.Read];\r\n                        var d = new Deferred<Events, Error>();\r\n                        this.getEvents(nextLink, endpoint, (error: Error, result: Events) => {\r\n                            if (callback)\r\n                                callback(error, result);\r\n                            else\r\n                                error ? d.reject(error) : d.resolve(result);\r\n                        }, this.scopesForV2(scopes));\r\n                        return d.promise;\r\n                    }\r\n                }\r\n                callback(null, events);\r\n            }, null, scopes);\r\n        }\r\n\r\n\r\n        private getGroups(urlString: string, callback: PromiseCallback<Groups>, scopes?:string[]): void {\r\n            this.get(urlString, (errorGet: Error, result: string) => {\r\n                if (errorGet) {\r\n                    callback(errorGet);\r\n                    return;\r\n                }\r\n\r\n                var groupsODATA = JSON.parse(result);\r\n                if (groupsODATA.error) {\r\n                    var errorODATA = new Error();\r\n                    errorODATA.other = groupsODATA.error;\r\n                    callback(errorODATA);\r\n                    return;\r\n                }\r\n\r\n                var resultsArray = (groupsODATA.value ? groupsODATA.value : [groupsODATA]) as any[];\r\n                var groups = new Groups(this, resultsArray.map(o => new Group(this, o)));\r\n                var nextLink = groupsODATA['@odata.nextLink'];\r\n                if (nextLink) {\r\n                    groups.nextLink = (callback: PromiseCallback<Groups>) => {\r\n                        var scopes = [Scopes.Group.ReadAll];\r\n                        var d = new Deferred<Groups,Error>();\r\n                        this.getGroups(nextLink, (error: Error, result: Groups) => {\r\n                            if (callback)\r\n                                callback(error, result);\r\n                            else\r\n                                error ? d.reject(error) : d.resolve(result);\r\n                        }, this.scopesForV2(scopes));\r\n                        return d.promise;\r\n                    }\r\n                }\r\n\r\n                callback(null, groups);\r\n            },null,scopes);\r\n        }\r\n\r\n        private getGroup(urlString: string, callback: PromiseCallback<Group>, scopes?:string[]): void {\r\n            this.get(urlString, (errorGet: Error, result: string) => {\r\n                if (errorGet) {\r\n                    callback(errorGet);\r\n                    return;\r\n                }\r\n                var ODATA = JSON.parse(result);\r\n                if (ODATA.error) {\r\n                    var ODATAError = new Error();\r\n                    ODATAError.other = ODATA.error;\r\n                    callback(ODATAError);\r\n                    return;\r\n                }\r\n                var group = new Group(this, ODATA);\r\n\r\n                callback(null, group);\r\n            },null,scopes);\r\n\r\n        }\r\n\r\n        private getPhoto(urlString, callback: PromiseCallback<ProfilePhoto>, scopes?:string[]): void {\r\n            this.get(urlString, (errorGet: Error, result: string) => {\r\n                if (errorGet) {\r\n                    callback(errorGet);\r\n                    return;\r\n                }\r\n                var ODATA = JSON.parse(result);\r\n                if (ODATA.error) {\r\n                    var errorODATA = new Error();\r\n                    errorODATA.other = ODATA.error;\r\n                    callback(errorODATA);\r\n                    return;\r\n                }\r\n                var photo = new ProfilePhoto(this, ODATA);\r\n\r\n                callback(null, photo);\r\n            },null,scopes);\r\n        }\r\n\r\n        private getPhotoValue(urlString, callback: PromiseCallback<any>, scopes?:string[]): void {\r\n            this.get(urlString, (errorGet: Error, result: any) => {\r\n                if (errorGet) {\r\n                    callback(null, errorGet);\r\n                    return;\r\n                }\r\n                callback(result);\r\n            }, \"blob\",scopes);\r\n        }\r\n\r\n        private getMailFolders(urlString, callback: PromiseCallback<MailFolders>, scopes?: string[]): void {\r\n            this.get(urlString, (errorGet: Error, result: string) => {\r\n                if (errorGet) {\r\n                    callback(errorGet);\r\n                    return;\r\n                }\r\n\r\n                var odata = JSON.parse(result);\r\n                if (odata.error) {\r\n                    var errorODATA = new Error();\r\n                    errorODATA.other = odata.error;\r\n                    callback(errorODATA);\r\n                }\r\n\r\n                var resultsArray:MailFolderDataModel[] = (odata.value ? odata.value : [odata]);\r\n                var mailFolders = new MailFolders(this, resultsArray.map(o => new MailFolder(this, o)));\r\n                var nextLink = odata['@odata.nextLink'];\r\n                if (nextLink) {\r\n                    mailFolders.nextLink = (callback?: PromiseCallback<MailFolders>) => {\r\n                        var scopes = [Scopes.User.ReadAll];\r\n                        var d = new Deferred<MailFolders,Error>();\r\n                        this.getMailFolders(nextLink, (error: Error, result: MailFolders) => {\r\n                            if (callback)\r\n                                callback(error, result);\r\n                            else\r\n                                error ? d.reject(error) : d.resolve(result);\r\n                        }, this.scopesForV2(scopes));\r\n                        return d.promise;\r\n                    }\r\n                }\r\n                callback(null, mailFolders);\r\n            },null,scopes);\r\n        }\r\n\r\n\r\n        private getMessageAttachments(urlString: string, callback: PromiseCallback<Attachments>, scopes?:string[]): void {\r\n            this.get(urlString, (errorGet: Error, result: string) => {\r\n                if (errorGet) {\r\n                    callback(errorGet);\r\n                    return;\r\n                }\r\n\r\n                var attachmentsODATA = JSON.parse(result);\r\n                if (attachmentsODATA.error) {\r\n                    var errorODATA = new Error();\r\n                    errorODATA.other = attachmentsODATA.error;\r\n                    callback(errorODATA);\r\n                    return;\r\n                }\r\n                var resultsArray = (attachmentsODATA.value ? attachmentsODATA.value : [attachmentsODATA]) as any[];\r\n                var attachments = new Attachments(this, resultsArray.map(o => new Attachment(this, o)));\r\n                var nextLink = attachmentsODATA['@odata.nextLink'];\r\n                if (nextLink) {\r\n                    attachments.nextLink = (callback?: PromiseCallback<Attachments>) => {\r\n                        var scopes = [Scopes.Mail.Read];\r\n                        var d = new Deferred<Attachments,Error>();\r\n                        this.getMessageAttachments(nextLink, (error: Error, attachments: Attachments) => {\r\n                            if (callback)\r\n                                callback(error, attachments);\r\n                            else\r\n                                error ? d.reject(error) : d.resolve(attachments);\r\n                        }, this.scopesForV2(scopes));\r\n                        return d.promise;\r\n                    }\r\n                }\r\n\r\n                callback(null, attachments);\r\n            },null,scopes);\r\n        }\r\n\r\n        private getMessageAttachment(urlString, callback: PromiseCallback<Attachment>, scopes?:string[]): void {\r\n            this.get(urlString, (errorGet: Error, result: string) => {\r\n                if (errorGet) {\r\n                    callback(errorGet);\r\n                    return;\r\n                }\r\n                var ODATA = JSON.parse(result);\r\n                if (ODATA.error) {\r\n                    var ODATAError = new Error();\r\n                    ODATAError.other = ODATA.error;\r\n                    callback(ODATAError);\r\n                    return;\r\n                }\r\n                var attachment = new Attachment(this, ODATA);\r\n\r\n                callback(null, attachment);\r\n            },null,scopes);\r\n        }\r\n\r\n        private buildUrl(root:string, path: string, odataQuery?: string) {\r\n            return this.baseUrl + root + path + (odataQuery ? \"?\" + odataQuery : \"\");\r\n        }\r\n        private buildMeUrl(path: string = \"\", odataQuery?: string) {\r\n            return this.buildUrl(\"me/\", path, odataQuery);\r\n        }\r\n        private buildUsersUrl(path: string = \"\", odataQuery?: string) {\r\n            return this.buildUrl(\"users/\", path, odataQuery);\r\n        }\r\n        private buildGroupsUrl(path: string = \"\", odataQuery?: string) {\r\n            return this.buildUrl(\"groups/\", path, odataQuery);\r\n        }\r\n    }\r\n\r\n//*********************************************************\r\n//\r\n//Kurve js, https://github.com/microsoftdx/kurvejs\r\n//\r\n//Copyright (c) Microsoft Corporation\r\n//All rights reserved.\r\n//\r\n// MIT License:\r\n// Permission is hereby granted, free of charge, to any person obtaining\r\n// a copy of this software and associated documentation files (the\r\n// \"\"Software\"\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to\r\n// permit persons to whom the Software is furnished to do so, subject to\r\n// the following conditions:\r\n\r\n\r\n\r\n\r\n// The above copyright notice and this permission notice shall be\r\n// included in all copies or substantial portions of the Software.\r\n\r\n\r\n\r\n\r\n// THE SOFTWARE IS PROVIDED \"\"AS IS\"\", WITHOUT WARRANTY OF ANY KIND,\r\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n//\r\n//*********************************************************\r\n"],"sourceRoot":"/source/"}